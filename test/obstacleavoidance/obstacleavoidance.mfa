program obstacleavoidance



group Axis [Driver,Front,Back]
group LeftWheel
group RightWheel

float PROXIMITY = 0.15
byte STEER_DEGREES = 15
float BACKWARD_TIME = 10
float TURNAROUND_TIME = 2

byte FORWARD = 1
byte BACKWARD = -1	

module {
	
} 

meta {
	byte size;
	
	void steer (int degrees) {
		rotate(@Axis.Front,STEER_DEGREES);
		rotate(@Axis.Back,-STEER_DEGREES);
	}
	
	void drive (byte dirLeft, byte dirRight) {
		rotate_continuous(@LeftWheel,dirLeft);
		rotate_continuous(@RightWheel,dirRight);
	}
	
	void halt () {
		// stop(@LeftWheel);
		// stop(@RightWheel);
	}
}

region {
	
}

sequence Main {
	do {
		when (#(connSource:SOUTH&EAST&FEMALE, connDest:EAST)>0) {
			module.group = @LeftWheel;
		}
		
		when (#(connSource:SOUTH&EAST&FEMALE, connDest:WEST)>0) {
			module.group = @RightWheel;
		} 
		
		when (#(@RightWheel)>0 || #(@LeftWheel)>0 && #(connSource: NORTH&EAST&FEMALE)==0) {
			module.id = @Axis.Front;
		}
		
		when (#(@RightWheel)>0 || #(@LeftWheel)>0 && #(connSource: NORTH&EAST&FEMALE)==0) {
			module.id = @Axis.Back;
		}
		
		when (#(@Axis) == 2) {
			module.id = @Axis.Driver;
		}
	} until (config.assignTime);
	
	goto Drive;
}	


sequence Drive {
 	when (module.group == @Axis && module.proximity() > PROXIMITY) {
		if (#(@Axis) == 2) {
			meta.size = 3;
			goto TurnTwoWheeler;
		}
		
		if (#(@Axis) == 3) {
			meta.size = 7;
			goto TurnFourWheeler;
		}	
	}	
	
	// FORWARD and BACKBWARD should be built in constants of 1 and -1, resp.
	meta.drive(FORWARD,FORWARD);
}




