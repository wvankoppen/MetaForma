package Christensen

debug {
	show [AssignMetaID,AddNeighbor,MetaVarSync,Gradient,Packet,Discover,Absorb,Region]
	
	visualize {  
	 	north {
	 		@X: blue;
	 		@Walker: cyan;
	 		@Uplifter: white; 
	 	}
	 	
	 	south { 
	 		Main: black; 
	 		Strategy: red;
	 		GetUp: green;
	 		WalkStep: brown;
	 		GetDown: purple; 	 
	 	} 
	} 
}


int HALF = 180
int QUART = 90
int EIGHT = 45

int DELAY_GETUP = 5
byte LYING = 0
byte STANDING = 1

group Walker[Left,Top,Right]
group Uplifter[Left]


packet AssignMetaID {
	byte newID, index;
}
  
packet AddNeighbor {
	byte first, second;
}

packet Gradient {
	byte pri, sec;
} 

packet Absorb {}

when (receive (AddNeighbor p)) {
	if (p.metaID != 0) {
		if (p.metaID == meta.Left) {
			meta.TopLeft = p.first;  
			meta.BottomLeft = p.second;
		}
		if (p.metaID == meta.Right) {
			meta.TopRight = p.first;
			meta.BottomRight = p.second;
		}
		if (p.metaID == meta.Top) {
			meta.TopLeft = p.first;
			meta.TopRight = p.second;
		}
		if (p.metaID == meta.Bottom) {
			meta.BottomLeft = p.first;
			meta.BottomRight = p.second;
		}
	}
}

when (receive (Absorb p)) {
	if (module.metaID == 0) {
		module.metaID = p.metaID;
		module.backupID();
		module.id = @Uplifter.Left; 
	}
}
 
 
when (receive (Gradient p)) {
	if (p.pri + 1 < module.gradPri || p.sec + 1 < module.gradSec) {
		module.gradPri = min (p.pri + 1,module.gradPri);
		module.gradSec = min (p.sec + 1,module.gradSec);
		module.gradientPropagate();
	}	
}

meta {
 	parts [LeftPart, TopPart, RightPart];	
 	 	 
	byte Top,Bottom,Left,Right, TopLeft,TopRight,BottomLeft,BottomRight, Up;
	byte type;

	void neighborHook (Packet p) {
		if (p.metaID != module.metaID && module.metaID != 0 && p.metaID != 0 && p.sourceGroup != @Walker) { // Walker not needs to be compromised
			if (meta.type==LYING || (module.id != @Walker.Left)) {
				if (module.metaPart == TopPart) 	Top = p.metaID;		
				if (module.metaPart == RightPart)	Bottom = p.metaID;
			}
		}
	}
 		
	void absorb() {
		if (module.id == @Walker.Right) { // Otherwise we might capture modules intended for meta-module
			unicast Absorb() to $(inRegion:false);
			meta.sizeExtra = 1;
		}
	} 
	 	
 }

 

module  { 
	border [
		LEFT: #(connSrc: EAST&MALE)>0; 
		RIGHT: #(connSrc: WEST&MALE)>0;
		TOP: #(connSrc: WEST&FEMALE)>0 && #(connSrc: EAST&FEMALE)==0;
		BOTTOM: #(connSrc: NORTH&MALE)==1 && #()==1; // #(connSrc: EAST&FEMALE)>0 && #(connSrc: WEST&FEMALE)==0;
	]
	
	boolean sourcePri, sourceSec;
	byte gradPri, gradSec;
	boolean isRef;
	
	void gradientPropagate () {		 
		if (sourcePri) gradPri = 0; 
		if (sourceSec) gradSec = 0;
		unicast Gradient(pri=gradPri, sec=gradSec) to $();
	} 		

	void gradientInit() {
		sourcePri = module.atBorder(orient.primary);
		sourceSec = module.atBorder(orient.secondary);
		
		gradPri = MAX_BYTE;
		gradSec = MAX_BYTE;			
	}
 }

  
sequence Main {
	when (receive (Packet p)) {
		meta.neighborHook (p);
	}
	 
	do {  
		when (module.metaID == 0 && #(connSrc: EAST&MALE&NORTH, metaPart:None)>0 && #(connSrc: WEST&MALE&NORTH, metaID:0)==0) {
			module.metaID = module.number; 
			module.metaPart = LeftPart;
		}	
		// When a neighbor receives a packet, it sets its metaPart variable, and thus the above event will no longer trigger. Therefore use 2 events
		when (module.metaPart == LeftPart && module.metaID != 0) {
			unicast AssignMetaID (newID = module.metaID) to $(connSrc: EAST&MALE&NORTH);
		}
		
		when (receive (AssignMetaID p)) {
			byte index;
			module.metaID = p.newID;
				
			if (p.index == 0) {
				module.metaPart = TopPart; 
				index = 1;
			}
			else if (p.index == 1) {
				module.metaPart = RightPart;
				meta.enable(); 
				execute Strategy;
			}
			unicast AssignMetaID (newID = p.newID,index=index) to $(connSrc: pow2(mirror(p.connDest,true)));
		}
	} until (false); // No consensus here, as the final module will jump to Strategy when the meta-module is completed  
}