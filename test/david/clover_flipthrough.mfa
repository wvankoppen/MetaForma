import
	symmetry;

	
byte gradH = 255;
byte gradV = 255;

Group Uplifter {Top,Bottom,Left,Right}


function assign (byte h, byte v, Module m) {
	if (gradient(gradH) == h && gradient(gradV) == v) {
		setId(m);
		commit();
	}
}	

sequence FlipThrough {
	
	do  {
		assign(1,1, Left@Uplifter);
		assign(0,2, Right@Uplifter);
		assign(0,0, Top@Uplifter);
		assign(1,3, Bottom@Uplifter);
	} wait (consensus());
	
						
	do  {				
		disconnectPart(Left@Uplifter, NORTH&MALE&EAST|SOUTH&MALE&WEST);
		disconnectPart(Right@Uplifter, NORTH&MALE&EAST);
	} wait (consensus());
	
	do  {				
		rotate(Left@Uplifter, -90);
		rotate(Right@Uplifter, -90);
	} wait (consensus());
	
	disconnectPart(Top@Uplifter, NORTH);
	rotate(Top@Uplifter, -180);
	
	do  {				
		rotate(Left@Uplifter, -90);
		rotate(Right@Uplifter, -90);
	} wait (consensus());
	
	do  {				
		rotate(Right@Uplifter, -180);
		rotate(Bottom@Uplifter, 180);
	} wait (consensus());
	
	connect(@Floor, @Uplifter);	
	
	do {
		fixSymmetry ();
	} until (consensus());
	
	do {
		if (!@Floor) {
			renameRestore();
		}
	} wait (consensus());
	
}
