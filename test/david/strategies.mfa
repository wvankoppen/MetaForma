meta.discoverPeriodDirected = 5
meta.discoverPeriodUndirected = 7


meta {
	byte Top, Bottom, Left, Right, TopLeft,TopRight,BottomLeft,BottomRight;
}

MetaPacket AddNeighbor {
	byte first, second;
}

Packet MetaIdSet {
	byte newMetaID;
}

state Initialize {
	// During a sequence we should not add meta neighbors as the connector numbers can be swapped! So only do this at DEFAULT or INIT operation state
	when (receive (Packet p)) {
		meta.neighborHook (p);
	}
	
	
	do {
		when (#(EAST&MALE, module.role==None) == 2 && !$(WEST, module.role==None)) {
			meta.role = Left;
			meta.id = module.id;
			unicast MetaIdSet (newMetaID = module.id) on EAST&MALE&NORTH;
		}
		when (receive (MetaIdSet p)) {
			if (module.metaID == 0) {
				module.metaID = p.newMetaID;
				
				if (isMALE(p.destCon) && module.role == null) {
					module.role = Right;
				}
				else if (isWEST(p.destCon)  && module.role == null) {
					module.role = Top;
				}
				else if (isEAST(p.destCon)  && module.role == null) {
					module.role = Bottom;
				}
			}
			
			if (module.role == Left) {
				continue();
			}
			
			unicast MetaIdSet (newMetaID = p.newMetaID) on (pow2((p.destCon + 4) % 8)) rate 500ms;
		}	
	} 
	
	meta.enable();
	
	goto Choose;	
}


state Choose {
	when (receive (Packet p)) {
		// During a sequence we should not add meta neighbors as the connector numbers can be swapped! So only do this at DEFAULT or INIT operation state
		metaNeighborHook (p);
	}
	
	when (meta.Top != 0 && meta.Left == 0 && meta.Right == 0 && meta.TopLeft == 0 && meta.Bottom == 0) {
		region.create (id);
		region.enable([meta.top]);
		goto FlipBottom;
	}
	when (meta.Top == 0 && meta.Right != 0 && meta.TopRight == 0) {
		region.create (id);
		region.enable([meta.right]);
		goto FlipTop;
	}
	when (meta.Top == 0 && meta.Right != 0 && meta.TopRight != 0) {
		region.create (id);
		region.enable([meta.right,meta.topRight]);
		goto FlipUp;
	}

}





void metaNeighborHook (Packet p) { 
	if (p.metaID != module.metaID && module.metaID != 0) {
		if (p.destCon == 5 || p.destCon == 6) {
			if (meta.Right != metaId) {
				meta.Right = metaId;
				debug.print (".metaNeighborHook at " + p.destCon + " from meta module " + p.metaSourceID);
			}
		}
		if (p.destCon == 2 || p.destCon == 7) {
			if (meta.Top != metaId) {
				meta.Top = metaId;
				debug.print (".metaNeighborHook at " + p.destCon + " from meta module " + p.metaSourceID);
			}
		}
		if (p.destCon == 0 || p.destCon == 3) {
			if (meta.Left != metaId) {
				meta.Left = metaId;
				debug.print (".metaNeighborHook at " + p.destCon + " from meta module " + p.metaSourceID);
			}
		}
		if (p.destCon == 1 || p.destCon == 4) {
			if (meta.Bottom != metaId) {
				meta.Bottom = metaId;
				debug.print (".metaNeighborHook at " + p.destCon + " from meta module " + p.metaSourceID);
			}
		}
	}
}



void broadcastMetaNeighbors () {
	broadcastMetaNeighborsTo([meta.Top, meta.Bottom], meta.Left,meta.Right);
	broadcastMetaNeighborsTo([meta.Left, meta.Right], meta.Top, meta.Bottom);
}
	
void broadcastMetaNeighborsTo (byte[] dests, byte v1, byte v2) {
	for (byte dest:dests) {
		if (dest > 0) {
			send AddNeighbor(first:val1,second:val2) to dest;
		}
	}
	when (receive (AddNeighbor p)) {
		if (p.source == meta.Left)) {
			meta.TopLeft = p.first;
			meta.BottomLeft = p.second;
		}
		if (p.source == meta.Right)) {
			meta.TopRight = p.first;
			meta.BottomRight = p.second;
		}
		if (p.source == meta.Top)) {
			meta.TopLeft = p.first;
			meta.TopRight = p.second;
		}
		if (p.source == meta.Bottom)) {
			meta.BottomLeft = p.first;
			meta.BottomRight = p.second;
		}
	}
}


	