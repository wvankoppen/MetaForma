module Brandt

meta {
	part [Left, Top, Middle, Right];	
	
	byte Top, Bottom, Left, Right, TopLeft,TopRight,BottomLeft,BottomRight;
	
	void metaNeighborHook (Packet p) { 
		if (p.metaID != module.metaID && module.metaID != 0) {
			if (p.destCon == 5 || p.destCon == 6) {
				Right = p.metaId;
			}
			if (p.destCon == 2 || p.destCon == 7) {
				Top = p.metaId;
			}
			if (p.destCon == 0 || p.destCon == 3) {
				Left = p.metaId;
			}
			if (p.destCon == 1 || p.destCon == 4) {
				Bottom = p.metaId;
			}
		}
	}
		
	void broadcastMetaNeighbors () {
		broadcastMetaNeighborsTo([Top, Bottom], Left, Right);
		broadcastMetaNeighborsTo([Left, Right], Top, Bottom);
	}
		
	void broadcastMetaNeighborsTo (byte[] dests, byte v1, byte v2) {
		packet AddNeighbor {
			byte first, second;
		}

		for (byte dest:dests) {
			if (dest > 0) {
				send AddNeighbor(first=val1,second=val2) to dest;
			}
		}
		when (receive (AddNeighbor p)) {
			if (p.source == Left) {
				TopLeft = p.first;
				BottomLeft = p.second;
			}
			if (p.source == Right) {
				TopRight = p.first;
				BottomRight = p.second;
			}
			if (p.source == Top) {
				TopLeft = p.first;
				TopRight = p.second;
			}
			if (p.source == Bottom) {
				BottomLeft = p.first;
				BottomRight = p.second;
			}
		}
	}
}

module  {
	byte gradPri,gradSec;
	boolean isRef;
	boolean sourceH;
	boolean sourceV;	
	
	boolean left () {return $(EAST&MALE, inRegion:true) && !$(WEST&NORTH&MALE);}
	
		
	
	void gradientPropagate () { 
		if (sourceH){
			print("I am source for H");
			gradH = 0;
		}
		
		if (sourceV) {
			print("I am source for V");
			gradV = 0;
		}
		broadcast PacketGradient(h=gradH, v=gradV);
	}
	

	void gradientInit(boolean sH, boolean sV) {
		sourceH = sH;
		sourceV = sV;
		print("gradientInit()");
		gradH = MAX_BYTE;			
	}
}



// For gradients, the state does not matter so this is global	
when (receive (PacketGradient p)) {
	boolean updated;
	
	if (module.gradPri > p.pri + 1) {
		module.gradPri = p.pri + 1;
		updated = true;
	}
	if (module.gradSec > p.sec + 1) {
		module.gradSec = p.sec + 1;
		updated = true;
	}
	if (updated) {
		module.gradientPropagate();
	}
}



state Initialize {
	// During a sequence we should not add meta neighbors as the connector numbers can be swapped! So only do this at DEFAULT or INIT operation state
	when (receive (Packet p)) {
		meta.neighborHook (p);
	}
	
	
	do {
		packet MetaIdSet { byte newMetaID; }
		
		when (#(EAST&MALE, module.metaPart==None) == 2 && !$(WEST, module.metaPart==None)) {
			module.metaPart = Left;
			meta.id = module.id;
			unicast MetaIdSet (newMetaID = module.id) on EAST&MALE&NORTH;
		}
		when (receive (MetaIdSet p)) {
			if (module.metaID == 0) {
				module.metaID = p.newMetaID;
				
				if (isMALE(p.destCon) && module.metaPart == null) {
					module.metaPart = Right;
				}
				else if (isWEST(p.destCon) && module.metaPart == null) {
					module.metaPart = Top;
				}
				else if (isEAST(p.destCon) && module.metaPart == null) {
					module.metaPart = Bottom;
				}
				kill();
			}
			
			if (module.metaPart == Left) {
				continue();
			}
			
			unicast MetaIdSet (newMetaID = p.newMetaID) on (pow2((p.destCon + 4) % 8)) rate config.rate;
		}	
	} 
	
	meta.enable();
	
	goto Choose;	
}


state Choose {
	when (receive (Packet p)) {
		// During a sequence we should not add meta neighbors as the connector numbers can be swapped! So only do this at DEFAULT or INIT operation state
		metaNeighborHook (p);
	}
	
	
	when (meta.Top != 0 && meta.Left == 0 && meta.Right == 0 && meta.TopLeft == 0 && meta.Bottom == 0) {
		region.create ([meta.Top]) ;
		goto FlipThrough orientating UP_LEFT;
	}
	when (meta.Top == 0 && meta.Right != 0 && meta.TopRight == 0) {
		region.create ([meta.right]);
		goto FlipThrough orientating UP_LEFT;
	}
	when (meta.Top == 0 && meta.Right != 0 && meta.TopRight != 0) {
		region.enable([meta.right,meta.topRight]);
		goto FlipThrough orientating UP_LEFT;
	}

}
