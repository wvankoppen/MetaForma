meta.discoverPeriodDirected = 5
meta.discoverPeriodUndirected = 7


meta {
	byte Top, Bottom, Left, Right, TopLeft,TopRight,BottomLeft,BottomRight;
	
	void metaNeighborHook (Packet p) { 
		if (p.metaID != module.metaID && module.metaID != 0) {
			if (p.destCon == 5 || p.destCon == 6) {
				if (Right != metaId) {
					Right = metaId;
					debug.print (".metaNeighborHook at " + p.destCon + " from meta module " + p.metaSourceID);
				}
			}
			if (p.destCon == 2 || p.destCon == 7) {
				if (Top != metaId) {
					Top = metaId;
					debug.print (".metaNeighborHook at " + p.destCon + " from meta module " + p.metaSourceID);
				}
			}
			if (p.destCon == 0 || p.destCon == 3) {
				if (Left != metaId) {
					Left = metaId;
					debug.print (".metaNeighborHook at " + p.destCon + " from meta module " + p.metaSourceID);
				}
			}
			if (p.destCon == 1 || p.destCon == 4) {
				if (Bottom != metaId) {
					Bottom = metaId;
					debug.print (".metaNeighborHook at " + p.destCon + " from meta module " + p.metaSourceID);
				}
			}
		}
	}
		
	void broadcastMetaNeighbors () {
		broadcastMetaNeighborsTo([Top, Bottom], Left, Right);
		broadcastMetaNeighborsTo([Left, Right], Top, Bottom);
	}
		
	void broadcastMetaNeighborsTo (byte[] dests, byte v1, byte v2) {
		for (byte dest:dests) {
			if (dest > 0) {
				send AddNeighbor(first:val1,second:val2) to dest;
			}
		}
		when (receive (AddNeighbor p)) {
			if (p.source == Left)) {
				TopLeft = p.first;
				BottomLeft = p.second;
			}
			if (p.source == Right)) {
				TopRight = p.first;
				BottomRight = p.second;
			}
			if (p.source == Top)) {
				TopLeft = p.first;
				TopRight = p.second;
			}
			if (p.source == Bottom)) {
				BottomLeft = p.first;
				BottomRight = p.second;
			}
		}
	}
}

MetaPacket AddNeighbor {
	byte first, second;
}

Packet MetaIdSet {
	byte newMetaID;
}

state Initialize {
	// During a sequence we should not add meta neighbors as the connector numbers can be swapped! So only do this at DEFAULT or INIT operation state
	when (receive (Packet p)) {
		meta.neighborHook (p);
	}
	
	
	do {
		when (#(EAST&MALE, module.role==None) == 2 && !$(WEST, module.role==None)) {
			meta.role = Left;
			meta.id = module.id;
			unicast MetaIdSet (newMetaID = module.id) on EAST&MALE&NORTH;
		}
		when (receive (MetaIdSet p)) {
			if (module.metaID == 0) {
				module.metaID = p.newMetaID;
				
				if (isMALE(p.destCon) && module.role == null) {
					module.role = Right;
				}
				else if (isWEST(p.destCon)  && module.role == null) {
					module.role = Top;
				}
				else if (isEAST(p.destCon)  && module.role == null) {
					module.role = Bottom;
				}
			}
			
			if (module.role == Left) {
				continue();
			}
			
			unicast MetaIdSet (newMetaID = p.newMetaID) on (pow2((p.destCon + 4) % 8)) rate 500ms;
		}	
	} 
	
	meta.enable();
	
	goto Choose;	
}


state Choose {
	when (receive (Packet p)) {
		// During a sequence we should not add meta neighbors as the connector numbers can be swapped! So only do this at DEFAULT or INIT operation state
		metaNeighborHook (p);
	}
	
	when (meta.Top != 0 && meta.Left == 0 && meta.Right == 0 && meta.TopLeft == 0 && meta.Bottom == 0) {
		region.create (id);
		region.enable([meta.top]);
		goto FlipBottom;
	}
	when (meta.Top == 0 && meta.Right != 0 && meta.TopRight == 0) {
		region.create (id);
		region.enable([meta.right]);
		goto FlipTop;
	}
	when (meta.Top == 0 && meta.Right != 0 && meta.TopRight != 0) {
		region.create (id);
		region.enable([meta.right,meta.topRight]);
		goto FlipUp;
	}

}









	