module generate

imports
	
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MetaformaLang
  trans/constructors
  lib/editor-common.generated
  lib/compilation-library.generated
  libjava-front
  lib/editor-common.generated
  lib/index-library.generated
  lib/analysis-library.generated
  lib/analysis-library-internal.generated
  lib/compilation-library.generated
  lib/nbl-library.generated
	names
	desugar
	generate-indirect
	nblhacks
 
strategies

 
 
 to-java: Group (g,mods) -> <map2str(to-java(|g))>mods
 
 to-java(|g): Mod(n) -> $[[g]_[n],]
 to-java: Group(n) -> $[[n](true),]  
 
 
 
rules // Transformation to java strings.










add-glue(|glue): e -> (glue,e) 
concat-glue(|glue): [head|tail] ->  $[[head][<map(conc-strings)><map(add-glue(|glue))>tail]]
concat-glue(|glue): [] -> $[]

to-java-stat: exp -> $[[<to-java>exp];
]
where
	<debug(!"Compile stat: ")>exp

to-java: FuncCall(n,args) -> $[[<to-java>n]([<concat-glue(|",")><map(to-java)>args])]
to-java: ModHolderRef(g,m) -> $[Mod.[g]_[m]]
to-java: ModHolderRef(g) -> $[Group.[g]]  
to-java: FuncRef(n) -> n

to-java: OrientRef(o) -> $[Orientation.[o]]
to-java: MethodRef(obj,n) -> $[[<to-java>obj].[n]]

to-java: Break() -> $[mfStateMngr.nextInstruction()]

to-java-instr: Instr(i,evhdlrs,evsemi,stat*,postcon) -> $[ 
	[instr] 
	] 
where
	<debug>$[Instruction start [i]];
	<map2str(to-java)>evsemi => java-evsemi;
	<map2str(to-java-stat)>stat* => block;
	<to-java-stop(|i,java-evsemi,block)>postcon => instr;
	<debug>$[Instruction end [i]]

// to-java-all: Start(Module(m),defs,decls) -> $[public class [m]Controller extends MfController implements ControllerInformationProvider {
// 	[<concat><map(to-java-def)>defs]
// 	}]


// A doWait has no event habndlers because it is only evaluated once
to-java-stop(|i,java-evsemi,java-stats): Wait(wait) -> 
$[
	if (mfStateMngr.doWait([i]))  {
		[java-stats]
		[java-statemngr-call]
	}]
where
	<to-java-stop>wait => java-statemngr-call

to-java-stop(|i,java-evsemi,java-stats): Until(wait) -> $[
	if (mfStateMngr.doUntil([i]))  {
		[java-evsemi]
		[java-stats]
		[java-statemngr-call]
	}]
where
	<to-java-stop>wait => java-statemngr-call

to-java-stop: Consensus() -> $[mfStateMngr.commitEnd();]

to-java-stop: e -> $[mfStateMngr.spend([e']);] 
	where
		not (<?Consensus()>e);
		<to-java>e => e'




mod-enum: Mod(groupname,name) -> $[[groupname]_[name]]
mod-enum: Group(groupname) -> $[[groupname](true)]




to-java: TryRegion(n,o,incs,excls) -> $[region().tryRegion(new byte[brackets]{[<concat-glue(|",")><map(to-java)>incs]},new byte[brackets]{[<concat-glue(|",")><map(to-java)>excls]},[<to-java>n],[<to-java>o]);
]
where brackets := "[]"

to-java: OrientMatch(orients) -> $[[<concat-glue(|" || ")><map(orientref)>orients]
] 

orientref: OrientRef(r) -> $[mfStateMngr.getState().getOrientation().equals(Orientation.[r]))]


to-java: Goto(s) -> $[mfStateMngr.nextSequence([<to-java>s]);]


to-java: SequenceRef(n) -> $[Sequence.[n]] 
	// where 
	// 	not(<eq>(n,"Main"));
	// 	not(<eq>(n,"Choose"))
		
// to-java: SequenceRef("Choose") -> $[SequenceGeneric.Choose]
// to-java: SequenceRef("Main") -> $[SequenceGeneric.Main]
to-java: SequencePrimRef(n) -> $[SequenceGeneric.[n]]  


to-java: BinOp (op,e1,e2) -> $[([<to-java>e1] [<to-java>op] [<to-java>e2])]
// where <debug>"Compile BinOp"

to-java: AndBit() -> $[ & ]
to-java: OrBit() -> $[ | ]

to-java: And() -> $[ && ]
to-java: Or() -> $[ || ]
to-java: Eq() -> $[ == ]
to-java: Neq() -> $[ != ]
to-java: Modulo() -> $[ % ]
to-java: Plus() -> $[ + ]
to-java: Min() -> $[ - ]
to-java: Lt() -> $[ < ]
to-java: LtEq() -> $[ <= ]
to-java: Gt() -> $[ > ]
to-java: GtEq() -> $[ >= ]

to-java: Not(exp) -> $[ ![<to-java>exp] ]

to-java: Min(i) -> $[-[<to-java>i]]

to-java: Block(stats) -> $[[<concat-strings><map(to-java-stat)>stats]]

to-java: If(c,stats) -> $[ if ([<to-java>c]) {
		[<concat-strings><map(to-java-stat)>stats]
}]

to-java: IfElse(c,stats1,stats2) -> $[ if ([<to-java>c]) {
		[<concat-strings><map(to-java-stat)>stats1]
}
else {
		[<concat-strings><map(to-java-stat)>stats2]
}]

// to-java: FieldRef(obj,f) -> $[[<to-java>obj].getVar("[f]")]
to-java: d@FieldRef(obj,f) -> $[[<to-java>obj].[f]]
where 
	f' := <strip-annos>f;
	 not (<eq>(f',"id"));
	 not (<eq>(f',"group"))

to-java: FieldRef(obj, f) -> $[[<to-java>obj].getID()]
where 
	<eq>(<strip-annos>f,"id")
	
to-java: FieldRef(obj,f) -> $[[<to-java>obj].getGroup()]
where 
	<eq>(<strip-annos>f,"group")


to-java: ConstDecl(t,n,v) -> $[public final [<to-java>t] [n] = [<to-java>v]]

to-java: VarDecl(t,n) -> $[[<to-java>t] [n]]


to-java: Assign(v@VarRef(_), e) -> $[[<to-java>v] = [<to-java>e]]


to-java: Assign(FieldRef(obj,"id"),val) -> $[[<to-java>obj].setID([<to-java>val])]
to-java: Assign(FieldRef(obj,"group"),val) -> $[[<to-java>obj].setGroup([<to-java>val])]

to-java: Assign(FieldRef(obj,field),val) -> $[[<to-java>obj].setVar("[field]",[val'])]
where
	not(<eq>(field,"id"));
	not(<eq>(field,"group"));
	<to-java>val => val'

 

to-java: FuncDecl (n,params,evts,stats) -> $[ void [n] ([<concat-glue(|",")><map(to-java)>params]) {
	[<concat-strings><map(to-java-stat)>stats]	
	
}

]


to-java: Param(t,n) -> $[[<to-java>t] [n]]

	
to-java: Config() -> $[ctrl.config()]
to-java: Module() -> $[ctrl.module()]
to-java: Region() -> $[ctrl.region()]
to-java: Meta() -> $[ctrl.meta()]

to-java: Actuation() -> $[ctrl.getActuation()]


to-java: VarRef(n{[Var()|_]}) -> <strip-annos>n
to-java: VarRef(n{[MetaPart()|_]}) -> $[MetaPart.[<strip-annos>n]]

to-java: PayloadRef(p,n) -> n
to-java: Par(e) -> $[ ([<to-java>e]) ]

to-java: Const(n) -> $[MfController.[n]]
to-java: Null() -> $[null]
to-java: Int(i) -> i
to-java: Float(v) -> $[[v]f]
to-java: Bool(b) -> b

to-java: Int() -> $[int]
to-java: Byte() -> $[byte]
to-java: Float() -> $[float]
to-java: Boolean() -> $[boolean]

to-java: ByteArr() -> $[byte[brackets]] where
	brackets := "[]"

to-java: ByteArr(bytes) -> $[new byte [<bracks>]{[<concat-glue(|",")><map(to-java)>bytes]}]


to-java: NbsCount(exp) -> $[[<to-java>exp].size()]

to-java: NbsOp(constraints) -> $[ctrl.nbs()[<concat-strings><map(to-java)>constraints]]

to-java: NbsFilter(name,val) -> $[.nbsFilter[<to-upper-first>name]([<to-java>val])]

	  
to-java: PacketPrimRef(p) -> $[Packet[p]]
to-java: PacketRef(p) -> $[Packet[p]]


to-java: Unicast(p@PacketRef(packet),AssignList(assigns),dests,rate) -> $[
	if (ctrl.freqLimit("[packet]",[<compile-rate>rate])) {
		ctrl.unicast(([p'])new [p'](ctrl)[assigns'],[<to-java>dests]);
	}
	]
where
	p' := <to-java>p;
	assigns' := <map2str(to-java)>assigns


compile-rate: Some(Rate(exp)) -> <to-java>exp
compile-rate: None() -> $[true]

to-java: AssignElem(var,val) -> $[.setVar("[<to-java>var]",[<to-java>val])]





to-java: VisItem (_,hemisphere,ref,c) -> $[mfVisual.setColor("[<strip-annos>hemisphere]",[<to-java>ref],[<to-java>c]);
]

to-java: Color(c) -> $[Color.[c]]



	
to-java: MetaPart(n) -> $[[n],]

to-java: FieldDecl(t,n) -> $[[<to-java>t] [n];
]
to-java: PayloadDecl(t,n) -> $[[<to-java>t] [n];
]




to-java:  BorderItem(dir,exp) -> $[if (d.equals([<to-java>dir])) {
	ret = [<to-java>exp];
}
]
where <debug>"Compile BorderItem"

to-java: BorderLeft() -> $[BorderLine.LEFT]
to-java: BorderRight() -> $[BorderLine.RIGHT]
to-java: BorderTop() -> $[BorderLine.TOP]
to-java: BorderBottom() -> $[BorderLine.BOTTOM] 	 
