module generate

imports
	
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MetaformaLang
  trans/constructors
  lib/editor-common.generated
  lib/compilation-library.generated
  libjava-front
  lib/editor-common.generated
  lib/index-library.generated
  lib/analysis-library.generated
  lib/analysis-library-internal.generated
  lib/compilation-library.generated
  lib/nbl-library.generated
	names
	desugar

 
strategies
 
  
// generate :
    // msg -> 
    //   compilation-unit |[
    //     public class Print
    //     {
    //       public static void main(String[] ps)
    //       {
    //         System.err.println(~expr:msg);
    //       }
    //     }
    //  ]|
  
  
 
 
 to-java-mods: Def(Mod(),n,g,_) -> $[[g]_[n]]
 to-java-mods: Def(GroupNum(),n) -> $[[n](true)]  
 
 
 
rules // Transformation to java strings.



// to-java-all : Program(_,_,State(n,_,_,instrs)) -> $[sdds[<concat-strings><map(to-java-instrs)>instrs]]

to-java-all : Program(_,vis,defs,decls) -> $[[<concat-strings><map(to-java-decls)>decls]
]





add-glue(|glue): e -> (glue,e) 
concat-glue(|glue): [head|tail] ->  $[[head][<map(conc-strings)><map(add-glue(|glue))>tail]]
concat-glue(|glue): [] -> $[]


to-java: FuncCall(n,args) -> $[[<to-java>n]([<concat-glue(|",")><map(to-java)>args]);]
to-java: ModHolderRef(m,g) -> $[Mod.[g]_[m]]
to-java: ModHolderRef(g) -> $[Group.[g]]  
to-java: FuncRef(n) -> n
to-java: OrientRef(o) -> $[Orientation.[o]]
to-java: MethodRef(obj,n) -> $[[<to-java>obj].[n]]

to-java-instrs: Instr(c,d,stat*,postcon) -> $[ 
	[instr] 
	] 
where
	<debug>c;
	<concat-strings><map(to-java)>stat* => block;
	<to-java-stop(|c,block)>postcon => instr

// to-java-all: Start(Module(m),defs,decls) -> $[public class [m]Controller extends MfController implements ControllerInformationProvider {
// 	[<concat><map(to-java-def)>defs]
// 	}]

to-java-stop(|c,s): Wait(w) -> 
$[
	if (stateMngr.doWait([c]))  {
		[s]
		[mngr]
	}]
where
	<to-java-stop>w => mngr

to-java-stop(|c,s): Until(w) -> $[
	if (stateMngr.doUntil([c]))  {
		[s]
		[mngr]
	}]
where
	<to-java-stop>w => mngr

to-java-stop: Consensus() -> $[stateMngr.autoCommit();]

to-java-stop: e -> $[stateMngr.spend([e']);] 
	where
		not (<?Consensus()>e);
		<to-java>e => e'




// to-java-decls: Group(n,mod*) -> $[enum Mod {[mods]}]
// where
// 	<concat-glue(|",")><map(mod-enum)>mod* => mods 


mod-enum: Mod(groupname,name) -> $[[groupname]_[name]]
mod-enum: GroupNum(groupname) -> $[[groupname](true)]

to-java-decls: State(n,evhdlrs,vars,funcs,instrs) -> 
$[if (mfStateMngr.at(StateOperation.[n])) {  [<concat-strings><map(to-java-instrs)>instrs]
}
]


to-java: TryRegion(n,o,incs,excls) -> $[meta().tryRegion([<to-java>incs],[<to-java>excls],[<to-java>n],[<to-java>o]);
]

to-java: OrientMatch(orients) -> $[[<concat-glue(|" || ")><map(orientref)>orients]
] 

orientref: OrientRef(r) -> $[mfStateMngr.getState().getOrientation(Orientation.[r]))]


to-java: Goto(s) -> $[mfStateMngr.nextOperation([<to-java>s]);]


to-java: StateRef(n) -> $[StateOperation.[n]] 


to-java: BinOp (op,e1,e2) -> $[([<to-java>e1] [<to-java>op] [<to-java>e2])]

to-java: And() -> $[ && ]
to-java: Or() -> $[ || ]
to-java: Eq() -> $[ == ]
to-java: Neq() -> $[ != ]
to-java: Plus() -> $[ + ]
to-java: Min() -> $[ - ]
to-java: Lt() -> $[ < ]
to-java: LtEq() -> $[ <= ]
to-java: Gt() -> $[ > ]
to-java: GtEq() -> $[ >= ]

to-java: Min(i) -> $[-[<to-java>i]]

to-java: Block(stats) -> $[[<concat-strings><map(to-java)>stats]]

to-java: IfElse(c,stats1,stats2) -> $[ if ([<to-java>c]) {
		[<concat-strings><map(to-java)>stats1]
}
else {
		[<concat-strings><map(to-java)>stats2]
}
]

to-java: FieldRef(obj,f) -> $[[<to-java>obj].getVar("[f]")]

to-java: Assign(v@VarRef(_), e) -> $[[<to-java>v] = [<to-java>e];
]


to-java: VarRef(v) -> $[[v]]

to-java: Assign(FieldRef(obj,field),val) -> $[[<to-java>obj].setVar("[field]",[val']);]
where
	<to-java>val => val'

 

to-java: FuncDecl (n,params,evts,stats) -> $[ void [n] ([<concat-glue(|",")><map(to-java)>params]) {
	[<concat-strings><map(to-java)>stats]	
	
}

]


to-java: Param(t,n) -> $[[<to-java>t] [n]]

	
to-java: Config() -> $[config()]
to-java: Module() -> $[module()]
to-java: Region() -> $[region()]
to-java: Meta() -> $[meta()]
to-java: Actuation() -> $[mfActuation]

to-java: VarRef(n) -> n
to-java: PayloadRef(n) -> n
to-java: Par(e) -> $[ ([<to-java>e]) ]

to-java: Const(n) -> n
to-java: Int(i) -> i
to-java: Bool(b) -> b

to-java: Byte() -> $[byte]
to-java: Boolean() -> $[boolean]

to-java: ByteArr() -> $[byte[brackets]] where
	brackets := "[]"

to-java: ByteArr(bytes) -> $[new byte [brackets]{[<concat-glue(|",")><map(to-java)>bytes]}]
where
	brackets := "[]"

to-java: Receive(p,var) -> $[
	public boolean receivePacket ([p] p) {
	
]

to-java: PacketRef(p) -> $[Packet[p]]

to-java: Unicast(p@PacketRef(_),AssignList(assigns),dests,rate) -> $[send(([p'])new [p'](ctrl)[assigns'],[<to-java>dests]);]
where
	p' := <to-java>p;
	assigns' := <concat-strings><map(to-java)>assigns


to-java: Unicast(p@PacketRef(_),AssignList(assigns),dests,rate) -> $[unicast(([p'])new [p'](ctrl)[assigns'],[<to-java>dests]);]
where
	p' := <to-java>p;
	assigns' := <concat-strings><map(to-java)>assigns


to-java: AssignElem(var,val) -> $[.setVar("[<to-java>var]",[val])]



// index-lookup-type: 
// ref -> type 
// where
// definition := <index-lookup> ref ; 
// type := <index-get-data(|Type())> definition


to-java-decls: Visualize (vis) -> $[[<concat-strings><map(to-java)>vis]]

to-java: VisItem (g,StateRef(n),c,_) -> $[visual.setColor("[g]",Sequence.[n],Color.[c]);
]

to-java: VisItem (g,r@ModHolderRef(_,_),c,_) -> $[visual.setColor("[g]",[<to-java>r],Color.[c]);
]


to-java-decls: Class(Meta(),decls,funcs) -> $[class BagMeta extends CoreMeta implements IMetaBag {
	[decls']
	[funcs']
	}
	]
	where
		<concat-strings><map(to-java)>decls => decls';
		<concat-strings><map(to-java)>funcs => funcs'

to-java: MetaPartDecl (parts) -> $[enum MetaPart implements IMetaPart {
		NONE,[parts'];
	} 
	]
	where
		<concat-strings><map(to-java)>parts => parts'


to-java-decls: Class(Module(),decls,funcs) -> $[class BagModule extends CoreModule implements IModuleBag {
	[decls']
	[funcs']
	}
	]
	where
		<concat-strings><map(to-java)>decls => decls';
		<concat-strings><map(to-java)>funcs => funcs'

	
to-java: MetaPart(n) -> $[[n],]

to-java: FieldDecl(t,n) -> $[[<to-java>t] [n];
]
