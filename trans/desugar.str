module desugar

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MetaformaLang
  trans/constructors
  lib/editor-common.generated
  lib/compilation-library.generated
  libjava-front
  constructors
  store

rules // Incremental code generation of project using compilation library.
  
  
 
rules // Transformation to java strings.

head: [x|xs] -> x
tail: [x|xs] -> xs

 
desugar-all = innermost(desugar-functions);innermost(desugar);topdown(try(desugar-td));innermost(desugar)//;alltd(desugar-flatten)


desugar-td: Unicast(PacketRef(p),AssignList(assignlist),nbsop,rate) -> Unicast(PacketRef(p),AssignList(assignlist'),nbsop,rate)
where
	assignlist' := <map(desugar-payload(|<strip-annos>p))>assignlist
	

desugar-payload(|packet): AssignElem(PayloadRef(f),exp) -> AssignElem(PayloadRef(packet,f),exp)

// desugar-events3(|state,c): EvHdlr(r,decls,stats) -> EvHdlr(<newname>,State(state,c),r,decls,stats)
// desugar-events2(|state): EvHdlr(r,decls,stats) -> EvHdlr(<newname>,State(state),r,decls,stats)
// desugar-events: EvHdlr(r,decls,stats) -> EvHdlr(<newname>, State(),r,decls,stats)  

// desugar-td: Group (n,elems) -> Group (n,items)
// where
// 	<flatten-list><map(add-modgroup(|n))>elems => items
	
// add-modgroup(|g): Mod(n) -> Mod(g,n) 

desugar: EvHdlr(receive,vars,stats) -> EvHdlr (<newname>,receive,vars,stats)

desugar-td: Visualize (groups) -> Visualize (items)
where
	<flatten-list><map(rem-visgroup)>groups => items
	

rem-visgroup: VisGroup (n,g) -> g'
where
	<map(add-visgroup(|n))>g => g'


add-visgroup(|n): VisItem(r,c) -> VisItem(<newname>,n,r,c) 


// desugar-td: Program(n,vis,defs,decls) -> Program(n,vis,defs',decls)
// where
// 	<topdown(try(desugar-events))>defs => defs'

desugar-td: State(n,ehdlrs,ifs,x,e,instrs) -> State(n,ehdlrs,ifs,x,e,instrs''')  
where 
	<map(try(add-instrblock))>instrs => instrs';
	<upto><dec><length>instrs' => nrs;
	<zip>(nrs,instrs') => instrs'';
	// <map(try(desugar-events2(|n)))>ehdlrs => ehdlrs';
	<map(try(swap-counter(|n)))>instrs'' => instrs'''


// Desugar the vardecls out of an event
desugar: If (e,vardecls,stats) -> If(e,<conc>(vardecls,stats))


swap-counter(|state): (c,Instr(evts,evsemi,vars,instr*,postcon)) -> Instr(c,/*<map(try(desugar-events3(|state,c)))>*/evts,evsemi,<conc>(vars,instr*),postcon)
swap-counter(|state): (c,Instr(evts,evsemi,vars,instr*)) -> Instr(c,/*<map(try(desugar-events3(|state,c)))><filter(?event-real)>*/evts,evsemi,<conc>(vars,instr*),Wait(Consensus())) 

	
add-instrblock: f -> Instr([],[],[f])
where
	not (<?Instr(_,_,_,_,_,_)>f);
	not (<?Instr(_,_,_,_,_)>f);
	not (<?Instr(_,_,_,_)>f)
	


// desugar: VarDecl(t,n*) -> decls
// 	where
// 		<?[_|_]>n*;
// 		decls := <flatten-list><map(fixvar(|t))>n*
// 
// fixvar(|t): n -> VarDecl(t,n)


desugar-functions: Instr(d,evts,evsemi,instrs) -> Instr(d,evts,evsemi,instrs,Wait(Consensus()))  	 
 
// desugar-functions: ConnectPart(m1,m2) -> FuncCall(MethodRef(Actuation(),"connect_part"),[m1,m2])
// desugar-functions: DisconnectPart(m1,m2) -> FuncCall(MethodRef(Actuation(),"disconnect_part"),[m1,m2])
desugar-functions: Connect(_,m1,m2) -> FuncCall(MethodRef(Actuation(),"connect"),[m1,m2])
desugar-functions: Disconnect(_,m1,m2) -> FuncCall(MethodRef(Actuation(),"disconnect"),[m1,m2])
desugar-functions: Rotate(_,m1,deg) -> FuncCall(MethodRef(Actuation(),"rotate"),[m1,deg])
desugar-functions: RotateCont(_,m1,v) -> FuncCall(MethodRef(Actuation(),"rotate_continuous"),[m1,v])
desugar-functions: Stop(_,m1) -> FuncCall(MethodRef(Actuation(),"stop"),[m1])



desugar: Class(d@Meta(),metaparts,decls,funcs) -> Class(d,metaparts,<conc>(decls,funcs))
desugar: Class(d@Module(),decls,funcs) -> Class(d,(),<conc>(decls,funcs))

desugar: Block(stats) -> [stats]
where
	not(<?[_|_]>stats)
	
desugar: Block(stats) -> stats
where
	<?[_|_]>stats

desugar: MetaFieldRef(n) -> FieldRef(Meta(),n)	
	 
desugar: Nbs(d@NbsOp(_)) -> d
desugar: Nbs(d@NbsCount(_)) -> d  
	
desugar: Min(e1,e2) -> BinOp(Min(),e1,e2)
desugar: Plus(e1,e2) -> BinOp(Plus(),e1,e2)
desugar: Modulo(e1,e2) -> BinOp(Modulo(),e1,e2)
desugar: And(e1,e2) -> BinOp(And(),e1,e2)
desugar: Or(e1,e2) -> BinOp(Or(),e1,e2)
desugar: AndBit(e1,e2) -> BinOp(AndBit(),e1,e2)
desugar: OrBit(e1,e2) -> BinOp(OrBit(),e1,e2)
desugar: Eq(e1,e2) -> BinOp(Eq(),e1,e2)
desugar: Neq(e1,e2) -> BinOp(Neq(),e1,e2)
desugar: Lt(e1,e2) -> BinOp(Lt(),e1,e2)
desugar: LtEq(e1,e2) -> BinOp(LtEq(),e1,e2)
desugar: Gt(e1,e2) -> BinOp(Gt(),e1,e2)
desugar: GtEq(e1,e2) -> BinOp(GtEq(),e1,e2)


desugar: NbsOp (filters) -> NbsOp(filters')
where
	<eq>(<length><filter(?NbsFilter("inRegion",_))>filters,0);
	filters' := [NbsFilter("inRegion",Bool("true"))|filters]

desugar: NbsFilter(d@ModHolderRef(m)) -> NbsFilter("in",d)


desugar: FuncCall(MethodRef(Module(), "fixSymmetry"), [v]) -> 
Instr(
  [ EvHdlr(
      Receive(VarDecl(PacketRef("Symmetry"), "p"))
    , []
    , [ FuncCall(
          MethodRef(Module(), "fixSymmetry")
        , [FieldRef(VarRef("p"), "connSource"), FieldRef(VarRef("p"), "connDest")]
        )
      ]
    )
  ]
, []
, []
, [ If(
      v
    , [ Unicast(
          PacketRef("Symmetry")
        , AssignList([])
        , NbsOp([NbsFilter("inRegion", Bool("true"))])
        , None()
        )
      ]
    )
  ]
, Until(Consensus())
)

signature constructors
	EvHdlr : X * X * X * X * X -> EvHdlr
	VisItem : X * X * X * X -> VisItem

// desugar: Broadcast(p,assignlist,rate) -> Unicast(p,assignlist,Conn(),Int(255),rate)

