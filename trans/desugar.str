module desugar

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MetaformaLang
  trans/constructors
  lib/editor-common.generated
  lib/compilation-library.generated
  libjava-front
  constructors
  store
 metaformalang
rules 

 
// desugar-all = topdown(try(desugar-functions));innermost(desugar);topdown(try(desugar-td));innermost(desugar)
desugar-all = topdown(try(desugar-td));innermost(desugar)

desugar-td: Program(n,debug,decls) -> Program(n,debug,decls')
where
	// put the fakeclasses at the end of the list, so reference resolving resolves to the existing one, if any
	 decls' := <conc>([decls],[FakeClass(Module()),FakeClass(Meta()),FakeClass(Region())]) 
// Add fake declarations because not in every program we use the declaration, only the primitives
	

desugar-td: Unicast(Packet(p),AssignList(assignlist),nbsop) -> Unicast(Packet(p),AssignList(assignlist'),nbsop)
where
	assignlist' := <map(add-payload(|<strip-annos>p))>assignlist
	
	add-payload(|packet): AssignElem(PayloadRef(f),exp) -> AssignElem(PayloadRef(Packet(packet),f),exp)



desugar-td: Visualize (groups) -> Visualize (items)
where
	<flatten-list><map(rem-visgroup-container)>groups => items
	
	rem-visgroup-container: VisGroup (n,g) -> g'
	where
		<map(add-visgroup(|n))>g => g'

		add-visgroup(|n): VisItem(r,c) -> VisItem(<newname>,n,r,c) 


desugar-td: Sequence(n,ehdlrs,ifs,x,e,instrs) -> Sequence(n,ehdlrs,ifs,x,e,instrs''')  
where 
	<map(try(add-instrblock))>instrs => instrs';
	<upto><dec><length>instrs' => nrs;
	<zip>(nrs,instrs') => instrs'';
	<map(try(swap-counter(|n)))>instrs'' => instrs'''

	add-instrblock: f -> Instr([],[],[],[f])
	where
		not (<eq>(<aterm-name>f,"Instr"))

	swap-counter(|state): (c,Instr(evts,evsemi,vars,instr*,postcon)) -> Instr(c,evts,evsemi,<conc>(vars,instr*),postcon)
	swap-counter(|state): (c,Instr(evts,evsemi,vars,instr*)) -> Instr(c,evts,evsemi,<conc>(vars,instr*),Wait(Consensus())) 

// Because we need to match the enum with an object 
desugar-td: Eq(FieldPrimRef(Module(), "id"), ref) -> FuncCall(MethodRef(FuncCall(MethodRef(Module(),"getID"),[]), "equals"),[ref])


desugar-td: Instr(d,evts,evsemi,instrs) -> Instr(d,evts,evsemi,instrs,Wait(Consensus()))
  	 
// desugar-td: Connect(_,m1,m2,inRegion) -> FuncCall(MethodRef(Actuation(),"connect"),[m1,m2,inRegion])
// desugar-td: Disconnect(_,m1,m2,inRegion) -> FuncCall(MethodRef(Actuation(),"disconnect"),[m1,m2,inRegion])
// desugar-td: Rotate(_,m1,deg) -> FuncCall(MethodRef(Actuation(),"rotate"),[m1,deg])
// desugar-td: RotateCont(_,m1,v) -> FuncCall(MethodRef(Actuation(),"rotate_continuous"),[m1,v])
// desugar-td: Stop(_,m1) -> FuncCall(MethodRef(Actuation(),"stop"),[m1])


desugar: VarDecl(Boolean(),var) -> VarDecl(Boolean(),var,Bool("false"))
desugar: VarDecl(Byte(),var) -> VarDecl(Byte(),var,Int(0))
desugar: VarDecl(Int(),var) -> VarDecl(Int(),var,Int(0))
// desugar: FuncCall(FuncActuationRef(f), args) -> FuncCall(MethodRef(Actuation(),f),args)
// desugar-td: Connect("connect",ref1,ref2) -> Connect("connect",ref1,ref2,Bool("false"))
// desugar-td: Disconnect("disconnect",ref1,ref2) -> Disconnect("disconnect",ref1,ref2,Bool("false")) 

// Desugar the vardecls out of an event
desugar: If (e,vardecls,stats) -> If(e,<conc>(vardecls,stats))

desugar: EvHdlr(receive,vars,stats) -> EvHdlr (<newname>,receive,vars,stats)
desugar: ShowPackets(packets) -> DebugItem (ShowPackets(),packets)

desugar: Region(borders,funcs) -> Class(Region(),borders,funcs)
desugar: Meta(metaparts,decls,funcs) -> Class(Meta(),metaparts,<conc>(decls,funcs))
desugar: Module(decls,funcs) -> Class(Module(),(),<conc>(decls,funcs))

desugar: Block(stats) -> [stats]
where
	not(<?[_|_]>stats)
	
desugar: Block(stats) -> stats
where
	<?[_|_]>stats

desugar: MetaFieldRef(n) -> FieldRef(Meta(),n)	
	 
desugar: Nbs(d@NbsOp(_)) -> d
desugar: Nbs(d@NbsCount(_)) -> d  
	
desugar: Min(e1,e2) -> BinOp(Min(),e1,e2)
desugar: Plus(e1,e2) -> BinOp(Plus(),e1,e2)
desugar: Modulo(e1,e2) -> BinOp(Modulo(),e1,e2)
desugar: And(e1,e2) -> BinOp(And(),e1,e2)
desugar: Or(e1,e2) -> BinOp(Or(),e1,e2)
desugar: AndBit(e1,e2) -> BinOp(AndBit(),e1,e2)
desugar: OrBit(e1,e2) -> BinOp(OrBit(),e1,e2)

desugar: Eq(e1,e2) -> BinOp(Eq(),e1,e2)
desugar: Neq(e1,e2) -> BinOp(Neq(),e1,e2)
desugar: Lt(e1,e2) -> BinOp(Lt(),e1,e2)
desugar: LtEq(e1,e2) -> BinOp(LtEq(),e1,e2)
desugar: Gt(e1,e2) -> BinOp(Gt(),e1,e2)
desugar: GtEq(e1,e2) -> BinOp(GtEq(),e1,e2)


desugar: NbsOp (filters) -> NbsOp(filters')
where
	<eq>(<length><filter(?NbsFilter("inRegion",_))>filters,0);
	filters' := [NbsFilter("inRegion",Bool("true"))|filters]

desugar: NbsFilter(d@ModHolderRef(m)) -> NbsFilter("in",d)








desugar-all-nbl = topdown(try(desugar-nbl))
 
 // desugar-nbl: FieldPrimRef(o,f) -> FieldRef(o,f) NO!
desugar-nbl: PayloadPrimRef(o,f) -> FieldRef(o,f)
desugar-nbl: PayloadPrimRef(o,f) -> FieldRef(o,f)
desugar-nbl: MethodPrimRef(o,f) -> MethodRef(o,f)
desugar-nbl: FuncPrimRef(f) -> FuncRef(f)
//   desugar-nbl: SequenceName(n) -> SequenceRef(n)
// desugar-nbl: SequencePrimName(n) -> SequencePrimRef(n)





 
// move to generate phase.
// desugar: FuncCall(MethodRef(Module(), "fixSymmetry"), [v]) -> 
// Instr(
//   [ EvHdlr(
//       Receive(PacketVarDecl(Packet("Symmetry"), "p"))
//     , []
//     , [ FuncCall(
//           MethodRef(Module(), "fixSymmetry")
//         , [FieldRef(VarRef("p"), "connSource"), FieldRef(VarRef("p"), "connDest")]
//         )
//       ]
//     )
//   ]
// , []
// , []
// , [ If(
//       v
//     , [ Unicast(
//           Packet("Symmetry")
//         , AssignList([])
//         , NbsOp([NbsFilter("inRegion", Bool("true"))])
//         )
//       ]
//     )
//   ]
// , Until(Consensus())
// )

signature constructors
	ShowPackets: ShowPackets
	DebugItem: X * X -> DebugItem
	EvHdlr : X * X * X * X * X -> EvHdlr
	VisItem : X * X * X * X -> VisItem
	PrimRefPacket: X * X -> PrimRefPacket
	FakeClass: X -> FakeClass
	Class: X * X * X -> Class
