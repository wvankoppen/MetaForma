module desugar

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MetaformaLang
  trans/constructors
  lib/editor-common.generated
  lib/compilation-library.generated
  libjava-front
  constructors
  store
  metaformalang
  functions
rules 

 
// desugar-all = topdown(try(desugar-functions));innermost(desugar);topdown(try(desugar-td));innermost(desugar)
desugar-all = topdown(try(desugar-prepare));bottomup(try(desugar-td));innermost(desugar)

desugar-prepare= fail

// This needs to be done BEFORE inserting instruction blocks! 
// EDIT: NO!
// desugar-td: Strategy (n,evhdlrs,tryregions) -> Sequence(n,evhdlrs,[],[],[], [Instr(0,[],[],tryregions,Until(Bool("false")))])


desugar-td: TryRegion(n,o,incs,None()) -> TryRegion(n,o,incs,Some(Excluding([]))) 

desugar-td: Package(n,debug,decls) -> Package(n,debug,decls')
where
	// put the fakeclasses at the end of the list, so reference resolving resolves to the existing one, if any
	 decls' := [FakeClass(Module()),FakeClass(Meta()),FakeClass(Region())|decls]
// Add fake declarations because not in every package we use the declaration, only the primitives
	

desugar-td: Unicast(Packet(p),AssignList(assignlist),nbsop) -> Unicast(Packet(p),AssignList(assignlist'),nbsop)
where
	assignlist' := <map(add-payload(|<strip-annos>p))>assignlist
	
	add-payload(|packet): AssignElem(PayloadRef(f),exp) -> AssignElem(PayloadRef(Packet(packet),f),exp)


// desugar-td: Case(exp,stat) -> If (exp,[stat])	

desugar-td: Visualize (groups) -> Visualize (items)
where
	<flatten-list><map(rem-visgroup-container)>groups => items
	
	rem-visgroup-container: VisGroup (n,g) -> g'
	where
		<map(add-visgroup(|n))>g => g'

		add-visgroup(|n): VisItem(r,c) -> VisItem(<newname>,n,r,c) 


desugar-td: Sequence(n,ehdlrs,instrs) -> Sequence(n-cons,ehdlrs,instrs''')  
where
	n-cons := <seqname + seqnamePrim>n;
	<map(try(add-instrblock))>instrs => instrs';
	// <debug>instrs';
	<upto><dec><length>instrs' => nrs;
	<zip>(nrs,instrs') => instrs'';
	<map(swap-counter)>instrs'' => instrs'''

	add-instrblock: term -> Instr([],[],[],term')
	where
		not (<eq>(<aterm-name>term,"Instr"));
		if <is-list>term then
			term' := term
		else
			term' := [term]
		end

	swap-counter: (i,Instr(evts,vars,instr*,postcon))	-> Instr(i,evts,<conc>(vars,instr*),postcon)
	swap-counter: (i,Instr(evts,vars,instr*)) 			-> Instr(i,evts,<conc>(vars,instr*),Wait(Consensus())) 

	seqnamePrim: n@"Main" -> Main(n)	// To make NBL rules mutually excl. 
	seqnamePrim: n@"Strategy" -> Strategy(n)
	seqname: n -> Plain(n) where not (<seqnamePrim>n)

	decl2assign: VarDecl(t,n,v) -> Assign(VarRef(n),v)

// If origin tracking fails:
// <origin-track-forced(FieldRef(Module(),"QUART"))> a 
	
	// desugar: VarRef(a@"QUART") -> FieldRef(Module(), a) // Only in sequence
	// desugar: VarRef(a@"HALF") -> FieldRef(Module(), a)
	// desugar: VarRef(a@"EIGHT") -> FieldRef(Module(), a)

desugar-td: Neq(e1,e2) -> Not(Eq(e1,e2)) // Because of .equals in Java

desugar-td: Instr(d,evts,instrs) -> Instr(d,evts,instrs,Wait(Consensus()))
  	 
// desugar-td: Connect(_,m1,m2,inRegion) -> FuncCall(MethodRef(Actuation(),"connect"),[m1,m2,inRegion])
// desugar-td: Disconnect(_,m1,m2,inRegion) -> FuncCall(MethodRef(Actuation(),"disconnect"),[m1,m2,inRegion])
// desugar-td: Rotate(_,m1,deg) -> FuncCall(MethodRef(Actuation(),"rotate"),[m1,deg])
// desugar-td: RotateCont(_,m1,v) -> FuncCall(MethodRef(Actuation(),"rotate_continuous"),[m1,v])
// desugar-td: Stop(_,m1) -> FuncCall(MethodRef(Actuation(),"stop"),[m1])


// Needs to be done prior to desugar sequences ????NOT SURE
desugar-td: VarDecl(Boolean(),var) -> VarDecl(Boolean(),var,Bool("false"))
desugar-td: VarDecl(Byte(),var) -> VarDecl(Byte(),var,Int(0))
desugar-td: VarDecl(Int(),var) -> VarDecl(Int(),var,Int(0))
// desugar: FuncCall(FuncActuationRef(f), args) -> FuncCall(MethodRef(Actuation(),f),args)
// desugar-td: Connect("connect",ref1,ref2) -> Connect("connect",ref1,ref2,Bool("false"))
// desugar-td: Disconnect("disconnect",ref1,ref2) -> Disconnect("disconnect",ref1,ref2,Bool("false")) 

// Desugar the vardecls out of an event
desugar: If (e,vardecls,stats) -> If(e,<conc>(vardecls,stats))

desugar: EvHdlr(receive,vars,stats) -> EvHdlr (<newname>,receive,vars,stats)
desugar: ShowPackets(packets) -> DebugItem (ShowPackets(),packets)

// desugar: Region(borders,funcs) -> Class(Region(),borders,funcs)
desugar: Meta(metaparts,decls,funcs) -> Class(Meta(),metaparts,<conc>(decls,funcs))
desugar: Module(borders,decls,funcs) -> Class(Module(),borders,<conc>(decls,funcs))

 desugar: Block(stats) -> [stats]
 where
 	not(<is-list>stats)
 	
desugar: Block(stats) -> stats
 where
 	<is-list>stats

desugar: MetaFieldRef(n) -> FieldRef(Meta(),n)	
	 
desugar: Nbs(d@NbsOp(_)) -> d
desugar: Nbs(d@NbsCount(_)) -> d  
	
desugar: Min(e1,e2) -> BinOp(Min(),e1,e2)
desugar: Plus(e1,e2) -> BinOp(Plus(),e1,e2)
desugar: Mul(e1,e2) -> BinOp(Mul(),e1,e2)
desugar: Div(e1,e2) -> BinOp(Div(),e1,e2)
desugar: Modulo(e1,e2) -> BinOp(Modulo(),e1,e2)
desugar: And(e1,e2) -> BinOp(And(),e1,e2)
desugar: Or(e1,e2) -> BinOp(Or(),e1,e2)
desugar: AndBit(e1,e2) -> BinOp(AndBit(),e1,e2)
desugar: OrBit(e1,e2) -> BinOp(OrBit(),e1,e2)

desugar: Eq(e1,e2) -> BoolOp(Eq(),e1,e2)
desugar: Neq(e1,e2) -> BoolOp(Neq(),e1,e2)
desugar: Lt(e1,e2) -> BoolOp(Lt(),e1,e2)
desugar: LtEq(e1,e2) -> BoolOp(LtEq(),e1,e2)
desugar: Gt(e1,e2) -> BoolOp(Gt(),e1,e2)
desugar: GtEq(e1,e2) -> BoolOp(GtEq(),e1,e2)


desugar: NbsOp (filters) -> NbsOp(filters')
where
	<eq>(<length><filter(?NbsFilter("inRegion",_))>filters,0);
	filters' := [NbsFilter("inRegion",Bool("true"))|filters]

desugar: NbsFilter(d@ModHolderRef(m)) -> NbsFilter("in",d)
desugar: NbsFilter(d@ModHolderPrimRef()) -> NbsFilter("in",d)








desugar-all-nbl = bottomup(try(desugar-nbl))
 
 // desugar-nbl: FieldPrimRef(o,f) -> FieldRef(o,f) NO!
// desugar-nbl: PayloadPrimRef(o,f) -> FieldRef(o,f) ALSO NO! wrt getters and setters for prims
desugar-nbl: MethodPrimRef(o,f) -> MethodRef(o,f)
desugar-nbl: FuncPrimRef(f) -> FuncRef(f)
desugar-nbl: ModHolderPrimRef() -> ModHolderRef("X")
desugar-nbl: ModHolderPrimNumRef(i) -> ModHolderNumRef("X",i)
//   desugar-nbl: SequenceName(n) -> SequenceRef(n)
// desugar-nbl: SequencePrimName(n) -> SequencePrimRef(n)


// Because we need to match the enum with an object 
// We need to do this AFTER type checking!
desugar-nbl: BoolOp(Eq(),FieldPrimRef(Module(), "id"), e2) -> FuncCall(MethodRef(FuncCall(MethodRef(Module(),"getID"),[]), "equals"),[e2])
desugar-nbl: BoolOp(Eq(),PayloadPrimRef(p, "sourceID"), e2) -> FuncCall(MethodRef(FuncCall(MethodRef(p,"getSource"),[]), "equals"),[e2])

 
// move to generate phase.
// desugar: FuncCall(MethodRef(Module(), "fixSymmetry"), [v]) -> 
// Instr(
//   [ EvHdlr(
//       Receive(PacketVarDecl(Packet("Symmetry"), "p"))
//     , []
//     , [ FuncCall(
//           MethodRef(Module(), "fixSymmetry")
//         , [FieldRef(VarRef("p"), "connSource"), FieldRef(VarRef("p"), "connDest")]
//         )
//       ]
//     )
//   ]
// , []
// , []
// , [ If(
//       v
//     , [ Unicast(
//           Packet("Symmetry")
//         , AssignList([])
//         , NbsOp([NbsFilter("inRegion", Bool("true"))])
//         )
//       ]
//     )
//   ]
// , Until(Consensus())
// )

signature constructors
	ShowPackets: ShowPackets
	DebugItem: X * X -> DebugItem
	EvHdlr : X * X * X * X * X -> EvHdlr
	VisItem : X * X * X * X -> VisItem
	PrimRefPacket: X * X -> PrimRefPacket
	FakeClass: X -> FakeClass
	Class: X * X * X -> Class
	