module desugar

imports
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MetaformaLang
  trans/constructors
  lib/editor-common.generated
  lib/compilation-library.generated
  libjava-front
  constructors
  

rules // Incremental code generation of project using compilation library.
  
  
 
rules // Transformation to java strings.

head: [x|xs] -> x
tail: [x|xs] -> xs



desugar-all = innermost(desugar-functions);innermost(desugar);topdown(try(desugar-td));innermost(desugar)//;alltd(desugar-flatten)

desugar-events(|state,c): EvHdlr(r,decls,stats) -> EvHdlr(State(state,c),r,decls,stats) 

desugar-td: Group (n,elems) -> Group (n,items)
where
	<flatten-list><map(add-modgroup(|n))>elems => items
	
add-modgroup(|g): Mod(n) -> Mod(g,n) 

desugar-td: Visualize (groups) -> Visualize (items)
where
	<flatten-list><map(rem-visgroup)>groups => items
	

rem-visgroup: VisGroup (n,g) -> g'
where
	<map(add-visgroup(|n))>g => g'


add-visgroup(|n): VisItem(r,c,nr) -> VisItem(n,r,c,nr) 

desugar-td: State(n,e,x,instrs) -> State(n,e,x,instrs''')  
where 
	<map(try(add-instrblock))>instrs => instrs';
	<upto><dec><length>instrs' => nrs;
	<zip>(nrs,instrs') => instrs'';
	<map(try(swap-counter(|n)))>instrs'' => instrs'''
	// <map(try(add-ix))>instrs' => instrs''


swap-counter(|state): (c,Instr(d,instr*,postcon)) -> Instr(c,d,<map(try(desugar-events(|state,c)))>instr*,postcon)
swap-counter(|state): (c,Instr(d,instr*)) -> Instr(c,d,<map(try(desugar-events(|state,c)))>instr*,Wait(Consensus())) 

	
add-instrblock: f -> Instr([],[f])
where
	not (<?Instr(_,_)>f);
	not (<?Instr(_,_,_)>f);
	not (<?Instr(_,_,_,_)>f)


// desugar: VarDecl(t,n*) -> decls
// 	where
// 		<?[_|_]>n*;
// 		decls := <flatten-list><map(fixvar(|t))>n*
// 
// fixvar(|t): n -> VarDecl(t,n)


desugar-functions: Instr(d,instrs) -> Instr(d,instrs,Wait(Consensus()))  	 
 
desugar-functions: ConnectPart(m1,m2) -> FuncCall(MethodRef(Actuation(),"connect_part"),[m1,m2])
desugar-functions: DisconnectPart(m1,m2) -> FuncCall(MethodRef(Actuation(),"disconnect_part"),[m1,m2])
desugar-functions: Connect(m1,m2) -> FuncCall(MethodRef(Actuation(),"connect"),[m1,m2])
desugar-functions: Disconnect(m1,m2) -> FuncCall(MethodRef(Actuation(),"disconnect"),[m1,m2])
desugar-functions: Rotate(m1,deg) -> FuncCall(MethodRef(Actuation(),"rotate"),[m1,deg])
desugar-functions: RotateCont(m1,v) -> FuncCall(MethodRef(Actuation(),"rotate_continuous"),[m1,v])

desugar: If(c,stats) -> IfElse(c,stats,[])


desugar: Block(stats) -> [stats]
where
	not(<?[_|_]>stats)
	
desugar: Block(stats) -> stats
where
	<?[_|_]>stats
	
desugar: Min(e1,e2) -> BinOp(Min(),e1,e2)
desugar: Plus(e1,e2) -> BinOp(Plus(),e1,e2)
desugar: And(e1,e2) -> BinOp(And(),e1,e2)
desugar: Or(e1,e2) -> BinOp(Or(),e1,e2)
desugar: Eq(e1,e2) -> BinOp(Eq(),e1,e2)
desugar: Neq(e1,e2) -> BinOp(Neq(),e1,e2)
desugar: Lt(e1,e2) -> BinOp(Lt(),e1,e2)
desugar: LtEq(e1,e2) -> BinOp(LtEq(),e1,e2)
desugar: Gt(e1,e2) -> BinOp(Gt(),e1,e2)
desugar: GtEq(e1,e2) -> BinOp(GtEq(),e1,e2)





desugar: EvHdlr (Event(e),vardecls,stats) -> If(e,<conc>(vardecls,stats))
desugar: Broadcast(p,assignlist,rate) -> Unicast(p,assignlist,Conn(),Int(255),rate)
