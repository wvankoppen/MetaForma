module generate-indirect

imports
	
  libstratego-lib
  libstratego-gpp
  libstratego-aterm
  include/MetaformaLang
  trans/constructors
  lib/editor-common.generated
  lib/compilation-library.generated
  libjava-front
  lib/editor-common.generated
  lib/index-library.generated
  lib/analysis-library.generated
  lib/analysis-library-internal.generated
  lib/compilation-library.generated
  lib/nbl-library.generated
	names
	desugar
	generate
 metaformalang
 store
 project
 
strategies
	bracks = !"[]"

	map2str(rule) = map(rule);concat-strings 

	compile-packet: Packet(packet,i,payloaddecls) -> $[
		class [packet'] extends Packet {
			
			public static byte getTypeNr() {return [i];}
			
			public [packet'](MfController c) {
				super(c);
				setType(getTypeNr());
			}
			
			@Override
			public String toStringPayload() {
				return "[java-fields-debug]";
			}
			
			@Override
			public Packet deserializePayload(byte[<bracks>] payload) {
				[java-fields-payloads]
				return this;
			}
		
			@Override
			public byte[<bracks>] serializePayload() {
				return new byte[<bracks>]{[<concat-glue(|",")>fieldnames]};
			}
			
			[java-fields]
		}
	]
	where
		<debug>$[Compile packet [packet]];
		packet' := $[[packet]Base];
		java-fields := <map2str(to-java-stat)>payloaddecls;
		fieldnames := <map(project-name)>payloaddecls;
		java-fields-payloads := <compile-payload-assign>fieldnames; 
		java-fields-debug := <concat-glue(|",")><map(field-debug)>fieldnames;
		<debug>"Finish compile packet"
	
	
	field-debug: fieldname -> code
	where
	code := $[[fieldname]= " + [fieldname] + "] 
	
	
	compile-payload-assign: fieldnames -> code 
	where
		indices := <upto><dec><length>fieldnames;
		fieldnames-nrs := <zip>(indices,fieldnames);
		<map2str(swap-index)>fieldnames-nrs => code
		
		
  swap-index: (index,fieldname) -> $[[fieldname] = payload$[$[index]$]$;]	
	
	 
 compile-packetreceive(|n): Packet(packet,i,payloaddecls) -> $[
  	public void receivePacket([packet]Base p) {
  		[code]
  	}
  ]
  where
  	<debug>"Compile packetreceive";
 	 <index-get-evhdlr(|n)> <strip-annos>packet => eventhandlers;
 	 <map(simplify)>eventhandlers => result;
  	code := <map2str(compile)>result => code
  	
 	 
 simplify: EvHdlr(_{[_,name,p]},receive,vardecls, stats) -> EvHdlr (State(),<conc>(vardecls,stats)) 	 
 simplify: EvHdlr(_{[_,name,seq,p]},receive,vardecls, stats) -> EvHdlr (State(seq),<conc>(vardecls,stats)) 	 
 simplify: EvHdlr(_{[_,name,instr, seq,p]},receive,vardecls, stats) -> EvHdlr (State(seq, instr),<conc>(vardecls,stats))	
 // simplify: x -> <debug(!"xxx")>x

// to-java-global(|what) = 
//  	<concat-strings><map(compile-class)><debug(!"classes:")><get-classes>
 	
 	
 // to-java-decls: Visualize (vis) -> $[[<concat-strings><map(to-java)>vis]]

compile: Class(d@Region(),borderitems,funcs) -> $[
	class BagRegion extends RegionCore {
				
		public boolean at(BorderLine d) {
			boolean ret = false;
			[<to-java>borderitems]
			return ret;
		}
		
		[<map2str(to-java)>funcs]
	}
]
where
	<debug>$[Compile Region class]


to-java: BorderDecl(items) -> <map2str(to-java)>items
to-java: None() -> $[]

 compile:  Class(id',_,elements) -> $[class Bag[n] extends [n]Core implements I[n]Bag {
	[elements']
	}
	]
	where
		n := <construct2name>id';
		<debug>$[Compile class [n]];
		<map2str(to-java)>elements => elements'


construct2name: Meta() -> $[Meta]
construct2name: Module() -> $[Module]
construct2name: Region() -> $[Region]
 
 compile: State(state,evhdlrs,evts,vars,funcs,instrs) -> 
$[if (mfStateMngr.at([n])) {
	[java-evts]  
	[java-instrs]
}
]
where
	n := <to-java>state; 
	<debug>$[COMPILE sequence [n]];
	<map2str(to-java)>evts => java-evts;
	<map2str(to-java-instr)>instrs => java-instrs
 
 
 // to-java-packetreceive = 
 // 	<concat-strings><map(compile)><get-packets>
 
 
 
  	
  compile: e@EvHdlr (state,stats) ->
  	$[if (mfStateMngr.check(p,[<to-java>state])) {
  		[<map2str(to-java-stat)>stats]
  	}]
  	where <debug>$[Compile EvHdlr];<debug>e
  	
  	
  to-java: State() -> $[true]
  to-java: State(n) -> $[new State(Sequence.[n])]
  to-java: State(n,i) -> $[new State(Sequence.[n],[i])]
  
  