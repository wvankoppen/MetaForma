module MetaformaLang

imports 
	Common
	Exp
	lexical/MetaformaLang-Identifiers

exports

sorts	Group MetaClass

  context-free start-symbols
  
    Start
 
  context-free syntax
  %% Definition:  INDIRECT code generation
  %% Declaration: DIRECT code generation
  
   "program" ID Visualize? Definition* Declaration*						-> Start {"Program"}
   %%ModuleDef GroupDef* Definition 						-> Start {"Start", scope(Include)}
    
    %% Declaration -> Definition
    
    "visualize" "{" VisGroup*"}" -> Visualize {"Visualize"}
    ID "{" VisItem* "}" 		 -> VisGroup{"VisGroup"}
	
	ModHolderOrStateRef ":" Color [0-9] ";" -> VisItem{"VisItem"}
    
    ModHolderRef -> ModHolderOrStateRef
    StateRef -> ModHolderOrStateRef
    
	GroupDef 										-> Definition
	Meta "{" PartDecl? FieldDecl* FuncDecl* "}" 	-> Definition{"Class"}
	Module "{" FieldDecl* FuncDecl* "}" 			-> Definition{"Class"}
	
	"meta" 							-> Meta{"Meta"}
	"module"						-> Module{"Module"}
	
	"void" ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "}"					-> FuncDecl{"FuncDecl"}
	Type ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "return" Exp ";" "}"	-> FuncDecl{"FuncDecl"}
	
	Type ID 			-> ParamListElem{"Param"}
	ID					-> Type{avoid}
	
	"packet" ID "{" PayloadDecl* "}" 					-> Definition{"Packet"}
	FuncDecl -> Declaration

	
	%%Type {ID ","}+ ";" -> VarDecl{"VarDecl"}
	Type ID ";" -> VarDecl{"VarDecl"}
	Type ID ";" -> FieldDecl{"FieldDecl"}
	Type ID ";" -> PayloadDecl{"PayloadDecl"}
	PacketRef ID -> PacketVarDecl{"VarDecl"}
	

	"part" "[" {MetaPart ","}* "]" ";" -> PartDecl{"MetaPartDecl"}
	ID 		-> MetaPart{"MetaPart"}
	
	ID 					-> Ref{"VarRef"}
	ID 					-> PayloadRef{"PayloadRef"}
	
	PayloadRef "=" ID			-> AssignElem{"AssignElem"}
	{AssignElem ","}*				-> AssignList{"AssignList"} 
	
	"sequence" ID "{" EvHdlr* VarDecl* FuncDecl*  Instr* "}" -> Declaration{"State"}
	
	
	EvHdlr										 -> Definition
	"when" "(" Receive ")" "{" VarDecl* Stmt* "}" -> EvHdlr{"EvHdlr"}
	
	"when" "(" EventExp ")" "{" VarDecl* Stmt* "}" -> Stmt{"If"}

	
	ID								-> PacketRef {"PacketRef"}
	
	"receive" "(" PacketVarDecl ")" 	-> Receive{"Receive"}
	Exp 							-> EventExp
	"rate" Ref						-> Rate{"Rate"}
	
	
	%% "to" "meta-module" -> DestSingle{"Meta"}
	%% "on" "connector" -> DestSingle{"Conn"}
	%% "to" "meta-modules" -> DestMulti{"Meta"}
	%% "on" "connectors" -> DestMulti{"Conn"}
	%% "in" "region" -> DestMulti{"Region"}
	
	
	"unicast" PacketRef "(" AssignList ")" "to" Nbs Rate? ";" -> Stmt{"Unicast"}
	%% "broadcast" PacketRef "(" AssignList ")" Rate? ";" -> Stmt{"Broadcast"}
	%% why broadcast? we always want to sent inside the same region, even for gradients and symmetry?
	
	
	Ref "=" Exp ";" -> Stmt{"Assign"}
	
	

	Stmt							-> Block{"Block"}
	"{" Stmt* "}" 							-> Block{"Block"}
		
	"if" "(" Exp ")" Block "else" Block 		-> Stmt{"IfElse"}
	
	"if" "(" Exp ")" Block 					-> Stmt{"If"}
		
	ID 										-> StateRef{"StateRef"}
	ID 										-> OrientRef{"OrientRef"}	
		
	Stmt -> Instr
	"goto" StateRef ";"							-> Stmt{"Goto"}
	"goto" ID "orientating" ID ";"			-> Stmt{"Goto"}
	
	"group" ID "[" {Mod ","}* "]" 			-> GroupDef{"Group"}
	"group" ID							-> GroupDef{"GroupNum"}
	
	ID 								-> Mod{"Mod"}
	
	"try" "region" StateRef "orientating" OrientRef "from" ByteList "excluding" ByteList ";" -> Stmt{"TryRegion"}
	
	 {Exp ","}* 				-> ByteList {"ByteArr"}
	
	"disconnect" "(" ModHolderRef "," ModHolderRef ")" ";"			-> Stmt{"Disconnect"}
	"connect" "(" ModHolderRef "," ModHolderRef ")" ";"			-> Stmt{"Connect"}
	"rotate" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"Rotate"}
	"rotate_continuous" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"RotateCont"}
	"disconnect_part" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"DisconnectPart"}
	"connect_part" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"ConnectPart"}
	
	"stop" "(" ModHolderRef ")" ";"			-> Stmt{"Stop"}
	
	
	
	"wait" "(" Stop ")" ";" -> StopCondition {"Wait"}
	"until" "(" Stop ")" ";" -> StopCondition{"Until"}
	
	"consensus" "(" ")" 	-> Stop {"Consensus"}
	Exp						-> Stop	
	
	
	ID -> FuncRef{"FuncRef"}
	
	Obj "." ID -> MethodRef{"MethodRef"}
	
	ID -> VarRef{"VarRef"}
	
	
	"orientation" "matches" {OrientRef ","}* -> Exp{"OrientMatch"}
	
	
	 "@" ID "." ID									-> ModHolderRef{"ModHolderRef"}
	"@" ID 											-> ModHolderRef{"ModHolderRef"}
	
	Obj "." ID 			-> Ref{"FieldRef"}
	

	SysObj -> Obj	
	ID -> Obj

	%% context-free priorities
	%% {
	%% "@" ID										-> ModHolderRef{"ModHolderRef"}
	%% } > {
	%% ID "@" ID									-> ModHolderRef{"ModHolderRef"}
	%% }
	%% 
	
	context-free priorities
	{
	"do" "{" EvHdlr* VarDecl* Stmt* "}" StopCondition  -> Instr{"Instr"}
	} > {
	"do" "{" EvHdlr* VarDecl* Stmt* "}" -> Instr{"Instr"}
	}
	
	
	context-free priorities
	{
	MethodRef	"(" {Exp "," }* ")" ";"  -> Stmt{"FuncCall"}
	MethodRef 	"(" {Exp "," }* ")" 	 -> Exp{"FuncCall"}
	} > {
	FuncRef  "(" {Exp "," }* ")"   			-> Exp{"FuncCall"}
	FuncRef  "(" {Exp "," }* ")" ";"			-> Stmt{"FuncCall"}
	}
	
	
	
	
	
	
	
	
	
	