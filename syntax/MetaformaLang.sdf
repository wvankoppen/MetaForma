module MetaformaLang

imports 
	Common
	Exp
	lexical/MetaformaLang-Identifiers

exports

sorts	Group MetaClass RotateContinuous

  context-free start-symbols
  
    Start
 
 

 
 
  context-free syntax
  %% Definition:  INDIRECT code generation
  %% Declaration: DIRECT code generation
  
   "program" ID Visualize? Definition* Declaration*						-> Start {"Program"}
    
    "visualize" "{" VisGroup*"}" -> Visualize {"Visualize"}
    ID "{" VisItem* "}" 		 -> VisGroup{"VisGroup"}
	
	ModHolderOrSeqRef ":" ColorRef ";" -> VisItem{"VisItem"}
    
    Color -> ColorRef{"Color"}
    
    ModHolderRef -> ModHolderOrSeqRef
    SequenceRef -> ModHolderOrSeqRef
    
	GroupDef 										-> Definition
	%% Robot "{" FuncDecl* "}" 			-> Definition{"Class"} use region for this!
	Meta "{" PartDecl? FieldDecl* FuncDecl* "}" 	-> Definition{"Class"}
	Module "{" FieldDecl* FuncDecl* "}" 			-> Definition{"Class"}
	Region "{" BorderDecl? FuncDecl* "}" 			-> Definition{"Class"}
	
	Type ID "=" Exp									-> Definition{"ConstDecl"}
	
	"borders" "[" BorderItem* "]"			-> BorderDecl{"BorderDecl"}
	
	Direction ":" Exp ";" -> BorderItem{"BorderItem"}
	
	"left" -> Direction{"BorderLeft"}
	"right" -> Direction{"BorderRight"}
	"top" -> Direction{"BorderTop"} 
	"bottom" -> Direction{"BorderBottom"}  
	
	"meta" 							-> Meta{"Meta"}
	"module"						-> Module{"Module"}
	%% "robot"						-> Robot{"Robot"}
	"region"						-> Region{"Region"}
	
	"void" ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "}"					-> FuncDecl{"FuncDecl"}
	Type ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "return" Exp ";" "}"	-> FuncDecl{"FuncDecl"}
	
	Type ID 			-> ParamListElem{"Param"}
	ID					-> Type{avoid}
	
	"packet" ID "{" PayloadDecl* "}" 					-> Definition{"Packet"}
	FuncDecl 											-> Declaration

	
	%%Type {ID ","}+ ";" -> VarDecl{"VarDecl"}
	Type ID ";" 				-> VarDecl{"VarDecl"}
	Type ID ";" 				-> FieldDecl{"FieldDecl"}
	Type ID ";" 				-> PayloadDecl{"PayloadDecl"}
	PacketRef ID 				-> PacketVarDecl{"VarDecl"}
	

	"part" "[" {MetaPart ","}* "]" ";" -> PartDecl{"MetaPartDecl"}
	ID 									-> MetaPart{"MetaPart"}
	
	ID 									-> Ref{"VarRef"}
	ID 									-> PayloadRef{"PayloadRef"}
	
	PayloadRef "=" Exp					-> AssignElem{"AssignElem"}
	{AssignElem ","}*					-> AssignList{"AssignList"} 
	
	"sequence" SequenceRef "{" EvHdlr* EvHdlrSemi* VarDecl* FuncDecl*  Instr* "}" -> Declaration{"Sequence"}
	
	
	EvHdlr										 -> Definition
	"when" "(" Receive ")" "{" VarDecl* Stmt* "}" -> EvHdlr{"EvHdlr"}
	
	"when" "(" EventExp ")" "{" VarDecl* Stmt* "}" -> EvHdlrSemi{"If"}
 	%%"when" "(" EventExp ")" "{" VarDecl* Stmt* "}" -> EvHdlr{"EvHdlr"}
	
	ID									-> PacketRef {"PacketRef"}
	
	"receive" "(" PacketVarDecl ")" 	-> Receive{"Receive"}
	Exp 								-> EventExp
	"rate" Ref							-> Rate{"Rate"}
	

	
	"unicast" PacketRef "(" AssignList ")" "to" Nbs Rate? ";" -> Stmt{"Unicast"}
	%% "broadcast" PacketRef "(" AssignList ")" Rate? ";" -> Stmt{"Broadcast"}
	%% why broadcast? we always want to sent inside the same region, even for gradients and symmetry?
	
	
	Ref "=" Exp ";" 				-> Stmt{"Assign"}
	
	

	Stmt							-> Block{"Block"}
	"{" Stmt* "}" 							-> Block{"Block"}
		
	"if" "(" Exp ")" Block "else" Block 		-> Stmt{"IfElse"}
	
	"if" "(" Exp ")" Block 					-> Stmt{"If"}
		
	
			
	
		
	ID 										-> OrientRef{"OrientRef"}	
		
	Stmt -> Instr
	"goto" SequenceRef ";"							-> Stmt{"Goto"}
	"goto" ID "orientating" ID ";"			-> Stmt{"Goto"}
	
	"group" ID "[" {Mod ","}* "]" 			-> GroupDef{"Group"}
	"group" ID							-> GroupDef{"Group"}
	
	ID 								-> Mod{"Mod"}
	
	"try" "region" SequenceRef "orientating" OrientRef "from" {MetaFieldRef ","}*  "excluding" {MetaFieldRef ","}*  ";" -> Stmt{"TryRegion"}
	
	 {Exp ","}* 				-> ByteList {"ByteArr"}
	 ID 		-> MetaFieldRef {"MetaFieldRef"}
	 

	
	Disconnect "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"Disconnect"}
	Connect "(" ModHolderRef "," Exp")" ";"			-> Stmt{"Connect"}
	Rotate "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"Rotate"}
	RotateContinuous "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"RotateCont"}
	%% "disconnect_part" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"DisconnectPart"}
	%% "connect_part" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"ConnectPart"}
	
	Stop "(" ModHolderRef ")" ";"			-> Stmt{"Stop"}
	
	"break" ";"	-> Stmt{"Break"}
	
	lexical syntax
	"stop" -> Stop
	"rotate_continuous" -> RotateContinuous	
	"rotate" -> Rotate
	"disconnect" -> Disconnect
	"connect" -> Connect


	context-free syntax
		
		
	
	%% Exp 			-> ModHolderOrExp
	%% ModHolderRef 	-> ModHolderOrExp
	
	"wait" "(" Stop ")" ";" -> StopCondition {"Wait"}
	"until" "(" Stop ")" ";" -> StopCondition{"Until"}
	
	"consensus" "(" ")" 	-> Stop {"Consensus"}
	Exp						-> Stop	
	
	
	ID -> FuncRef{"FuncRef"}
	
	Obj "." ID -> MethodRef{"MethodRef"}
	
	ID -> VarRef{"VarRef"}
	
	
	
	SequenceGeneric						-> SequenceRef{"SequenceGenericRef",prefer}
	ID		 							-> SequenceRef{"SequenceRef"}

	
	
	
	context-free priorities
	{
	 	%% "module" "." ModuleFieldID -> ModuleFieldRef{"ModuleFieldRef"}
	 	%% ModuleFieldRef -> Ref
	 	Obj "." ModuleFieldID 			-> Ref{"FieldRef"}
	} > {
		Obj "." ID 			-> Ref{"FieldRef"}
	 }
	
	lexical syntax
	"ID" -> ModuleFieldID
	"metaID" -> ModuleFieldID
	"metaPart" -> ModuleFieldID
	
	
	
	"Main" 									-> SequenceGeneric
	"Choose" 								-> SequenceGeneric
	
	context-free syntax
		ID -> ModuleFieldID{reject}
	 SysObj -> Obj
	VarRef -> Obj

	 "@" ID "." ID									-> ModHolderRef{"ModHolderRef"}
	"@" ID 											-> ModHolderRef{"ModHolderRef"}
	"orientation" "matches" {OrientRef ","}* -> Exp{"OrientMatch"}
	
	
	context-free priorities
	{
	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" StopCondition  -> Instr{"Instr"}
	} > {
	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" -> Instr{"Instr"}
	}
	
	
	context-free priorities
	{
	MethodRef	"(" {Exp "," }* ")" ";"  -> Stmt{"FuncCall"}
	MethodRef 	"(" {Exp "," }* ")" 	 -> Exp{"FuncCall"}
	} > {
	FuncRef  "(" {Exp "," }* ")"   			-> Exp{"FuncCall"}
	FuncRef  "(" {Exp "," }* ")" ";"			-> Stmt{"FuncCall"}
	}
	
	
	
	
	
	
	
	
	
	