module MetaformaLang

imports 
	Common
	Exp
	lexical/MetaformaLang-Identifiers

exports

sorts	Group MetaClass

  context-free start-symbols
  
    Start
 
  context-free syntax
  
  
  
   "program" ID Definition*  Decl* 						-> Start {"Program"}
   %%ModuleDef GroupDef* Definition 						-> Start {"Start", scope(Include)}
    
	GroupDef 										-> Definition
	Meta "{" PartDecl* FieldDecl* FuncDecl* "}" 	-> Definition{"Class"}
	Module "{" FieldDecl* FuncDecl* "}" 			-> Definition{"Class"}
	
	"meta" 							-> Meta{"Meta"}
	"module"						-> Module{"Module"}
	
	"void" ID "(" {ParamListElem ","}* ")" "{" Decl* Stmt* "}"					-> FuncDecl{"FuncDecl"}
	Type ID "(" {ParamListElem ","}* ")" "{" Decl* Stmt* "return" Exp ";" "}"	-> FuncDecl{"FuncDecl"}
	
	Type ID 			-> ParamListElem{"Param"}
	ID					-> Type{avoid}
	
	"packet" ID "{" PayloadDecl* "}" 					-> Decl{"Packet"}
	FuncDecl -> Decl

	
	%%Type {ID ","}+ ";" -> VarDecl{"VarDecl"}
	Type ID ";" -> VarDecl{"VarDecl"}
	Type ID ";" -> FieldDecl{"FieldDecl"}
	Type ID ";" -> PayloadDecl{"PayloadDecl"}
	
	"part" "[" {ID ","}* "]" ";" -> PartDecl{"MetaPartDecl"}
	
	ID 					-> Ref{"VarRef"}
	ID 					-> PayloadRef{"PayloadRef"}
	
	PayloadRef "=" Exp			-> Assign{"Assign"}
	{Assign ","}*		-> AssignLst{"AssignList"}
	
	"sequence" ID "{" VarDecl* FuncDecl* Instr* "}" -> Definition{"State"}
	"state" ID "{" EvHdlr* TryReg* "}" -> Definition{"State"}
	
	
	EvHdlr										 -> Definition
	"when" "(" Event ")" "{" VarDecl* Stmt* "}" -> EvHdlr{"EvHdlr"}
	
	EvHdlr -> Stmt
	
	ID								-> PacketRef {"PacketRef"}
	
	"receive" "(" PacketRef ID ")" 	-> Event{"Receive"}
	Exp 							-> Event{"Event"}
	"rate" Ref						-> Rate{"Rate"}
	
	"unicast" PacketRef "(" AssignLst ")" "on"  Exp  Rate? ";" -> Stmt{"Unicast"}
	"broadcast" PacketRef "(" AssignLst ")" Rate? ";" -> Stmt{"Broadcast"}
	"send" PacketRef "(" {Assign ","}* ")"	"to" Exp ";"			-> Stmt{"Send"}
	
	
	Ref "=" Exp ";" -> Stmt{"Assign"}
	

	Stmt							-> Block{"Block"}
	"{" Stmt* "}" 							-> Block{"Block"}
		
	"if" "(" Exp ")" Block "else" Block 		-> Stmt{"IfElse"}
	
	"if" "(" Exp ")" Block 					-> Stmt{"If"}
		
	ID 										-> StateRef{"StateRef"}	
		
	Stmt -> Instr
	"goto" StateRef ";"							-> Stmt{"Goto"}
	"goto" ID "orientating" ID ";"			-> Stmt{"Goto"}
	
	"group" ID "[" {Mod ","}* "]" 			-> GroupDef{"Group"}
	"group" ID							-> GroupDef{"GroupNum"}
	
	ID 								-> Mod{"Mod"}
	
	"try" "region" ID "orientating" ID "from" {ID ","}* "excluding" {ID ","}* ";" -> TryReg{"TryRegion"}
	
	 
	
	"disconnect" "(" ModHolderRef "," ModHolderRef ")" ";"			-> Stmt{"Disconnect"}
	"connect" "(" ModHolderRef "," ModHolderRef ")" ";"			-> Stmt{"Connect"}
	"rotate" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"Rotate"}
	"rotate_continuous" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"RotateCont"}
	"disconnect_part" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"DisconnectPart"}
	"connect_part" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"ConnectPart"}
	
	"stop" "(" ModHolderRef ")" ";"			-> Stmt{"Stop"}
	
	"for" "(" Type ID ":" ID")" Block				-> Stmt{"For"}
	
	
	
	
	"wait" "(" Stop ")" ";" -> StopCondition {"Wait"}
	"until" "(" Stop ")" ";" -> StopCondition{"Until"}
	
	"consensus" "(" ")" 	-> Stop {"Consensus"}
	Exp						-> Stop	
	
	
	
	
	Obj "." ID -> MethodRef{"MethodRef"}
	
	context-free priorities
	{
	Obj "." ID 			-> Ref{"FieldRef"}
	} > {
	ID "." ID 			-> Ref{"FieldRef"}
	}
	
	context-free priorities
	{
	"@" ID										-> ModHolderRef{"ModHolderRef"}
	} > {
	ID "@" ID									-> ModHolderRef{"ModHolderRef"}
	}
	
	
	context-free priorities
	{
	"do" "{" Decl* Stmt* "}" StopCondition  -> Instr{"Instr"}
	} > {
	"do" "{" Decl* Stmt* "}" -> Instr{"Instr"}
	}
	
	
	context-free priorities
	{
	MethodRef	"(" {Exp "," }* ")" ";"  -> Stmt{"FuncCall"}
	MethodRef 	"(" {Exp "," }* ")" 	 -> Exp{"FuncCall"}
	} > {
	ID  "(" {Exp "," }* ")"   			-> Exp{"FuncCall"}
	ID  "(" {Exp "," }* ")" ";"			-> Stmt{"FuncCall"}
	}
	
	
	
	
	
	
	
	
	
	