module MetaformaLang

imports 
	Common
	Exp
	lexical/MetaformaLang-Identifiers

exports

sorts	Group MetaClass RotateContinuous

  context-free start-symbols
  
    Start
 
 

 
 
  context-free syntax
  %% Definition:  INDIRECT code generation
  %% Declaration: DIRECT code generation
  
   "program" ID Visualize? Definition* Declaration*						-> Start {"Program"}
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Visualisation
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    "visualize" "{" VisGroup*"}" -> Visualize {"Visualize"}
    ID "{" VisItem* "}" 		 -> VisGroup{"VisGroup"}
	ModHolderOrSeqRef ":" ColorRef ";" -> VisItem{"VisItem"}
    
    Color -> ColorRef{"Color"}
    
    ModHolderRef -> ModHolderOrSeqRef
    SequenceRef -> ModHolderOrSeqRef
    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Header
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	GroupDef 										-> Definition

	Meta "{" PartDecl? FieldDecl* FuncDecl* "}" 	-> Definition{"Class"}
	Module "{" FieldDecl* FuncDecl* "}" 			-> Definition{"Class"}
	Region "{" BorderDecl? FuncDecl* "}" 			-> Definition{"Class"}
	
	Type ID "=" Exp									-> Definition{"ConstDecl"}
	
	"borders" "[" BorderItem* "]"			-> BorderDecl{"BorderDecl"}
	
	Direction ":" Exp ";" -> BorderItem{"BorderItem"}
	
	"left" -> Direction{"BorderLeft"}
	"right" -> Direction{"BorderRight"}
	"top" -> Direction{"BorderTop"} 
	"bottom" -> Direction{"BorderBottom"}  
	
	"meta" 							-> Meta{"Meta"}
	"module"						-> Module{"Module"}
	"region"						-> Region{"Region"}
	
	"void" ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "}"					-> FuncDecl{"FuncDecl"}
	Type ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "return" Exp ";" "}"	-> FuncDecl{"FuncDecl"}
	
	Type ID 			-> ParamListElem{"Param"}
	%% ID					-> Type{avoid}
	
	"packet" ID "{" PayloadDecl* "}" 					-> Definition{"Packet"}
	FuncDecl 											-> Declaration

	
	Type ID ";" 				-> VarDecl{"VarDecl"}
	Type ID ";" 				-> FieldDecl{"FieldDecl"}
	Type ID ";" 				-> PayloadDecl{"PayloadDecl"}
	PacketRef ID 				-> PacketVarDecl{"PacketVarDecl"}
	

	"part" "[" {MetaPart ","}* "]" ";" -> PartDecl{"MetaPartDecl"}
	ID 									-> MetaPart{"MetaPart"}
	
	ID 									-> Ref{"VarRef"}
	ID 									-> PayloadRef{"PayloadRef"}
	
	PayloadRef "=" Exp					-> AssignElem{"AssignElem"}
	{AssignElem ","}*					-> AssignList{"AssignList"} 
	"unicast" PacketRef "(" AssignList ")" "to" Nbs Rate? ";" -> Stmt{"Unicast"}
	"receive" "(" PacketVarDecl ")" 	-> Receive{"Receive"}
	
	"sequence" SequenceRef "{" EvHdlr* EvHdlrSemi* VarDecl* FuncDecl*  Instr* "}" -> Declaration{"Sequence"}
	
	
	EvHdlr										 -> Definition
	"when" "(" Receive ")" "{" VarDecl* Stmt* "}" -> EvHdlr{"EvHdlr"}
	
	"when" "(" EventExp ")" "{" VarDecl* Stmt* "}" -> EvHdlrSemi{"If"}
 	%%"when" "(" EventExp ")" "{" VarDecl* Stmt* "}" -> EvHdlr{"EvHdlr"}
	
	ID									-> PacketRef {"PacketRef"}
	PacketPrim							-> PacketRef {"PacketPrimRef"}
	
	PacketPrim	-> ID{reject}
	
	
	
	
	Exp 								-> EventExp
	"rate" Ref							-> Rate{"Rate"}
	

	
	
	
	
	
	Ref "=" Exp ";" 				-> Stmt{"Assign"}
	
	

	Stmt							-> Block{"Block"}
	"{" Stmt* "}" 							-> Block{"Block"}
		
	"if" "(" Exp ")" Block "else" Block 		-> Stmt{"IfElse"}
	
	"if" "(" Exp ")" Block 					-> Stmt{"If"}
		
	
			
	
		
	ID 										-> OrientRef{"OrientRef"}	
		
	Stmt -> Instr
	"goto" SequenceRef ";"							-> Stmt{"Goto"}
	"goto" ID "orientating" ID ";"			-> Stmt{"Goto"}
	
	"group" ID "[" {Mod ","}* "]" 			-> GroupDef{"Group"}
	"group" ID							-> GroupDef{"Group"}
	
	ID 								-> Mod{"Mod"}
	
	"try" "region" SequenceRef "orientating" OrientRef "from" {MetaFieldRef ","}*  "excluding" {MetaFieldRef ","}*  ";" -> Stmt{"TryRegion"}
	
	 {Exp ","}* 				-> ByteList {"ByteArr"}
	 ID 		-> MetaFieldRef {"MetaFieldRef"}
	 

	
	Disconnect "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"Disconnect"}
	Connect "(" ModHolderRef "," Exp")" ";"			-> Stmt{"Connect"}
	Rotate "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"Rotate"}
	RotateContinuous "(" ModHolderRef "," Exp ")" ";"			-> Stmt{"RotateCont"}

	
	Stop "(" ModHolderRef ")" ";"			-> Stmt{"Stop"}
	
	"break" ";"	-> Stmt{"Break"}
	
	lexical syntax
	"stop" -> Stop
	"rotate_continuous" -> RotateContinuous	
	"rotate" -> Rotate
	"disconnect" -> Disconnect
	"connect" -> Connect
	
	"Packet" -> PacketPrim

	context-free syntax
		
		
	
	Exp 			-> ModHolderOrExp
	ModHolderRef 	-> ModHolderOrExp
	
	"wait" "(" Stop ")" ";" -> StopCondition {"Wait"}
	"until" "(" Stop ")" ";" -> StopCondition{"Until"}
	
	"consensus" "(" ")" 	-> Stop {"Consensus"}
	Exp						-> Stop	
	
	
	ID -> FuncRef{"FuncRef"}
	
	SysObj "." ID 					-> MethodRef{"MethodRef"}
	Meta "." MetaMethodRef 		-> MethodRef{"MethodPrimRef"}
	Region "." RegionMethodRef 		-> MethodRef{"MethodPrimRef"}
	
	ID -> VarRef{"VarRef"}
	
	
	
	SequencePrim						-> SequenceRef{"SequencePrimRef",prefer}
	ID		 							-> SequenceRef{"SequenceRef"}

	
	
	
	Meta "." MetaFieldID 			-> Ref{"FieldPrimRef"}
	Module "." ModuleFieldID 		-> Ref{"FieldPrimRef"}
	SysObj "." ID					-> Ref{"FieldRef"}
	
	PacketVarRef "." PayloadID 						-> Ref{"PayloadPrimRef"}
	PacketVarRef "." ID 						-> Ref{"PayloadRef"}
	VarRef 						-> PacketVarRef

	 
	ModuleFieldID 	-> ID{reject}
	MetaFieldID  	-> ID{reject}
	MetaMethodRef  	-> ID{reject}
	RegionMethodRef -> ID{reject}
	PayloadID 		-> ID{reject}
	
	lexical syntax
	"id" -> ModuleFieldID 
	"id" -> MetaFieldID
	"metaID" -> ModuleFieldID
	"metaPart" -> ModuleFieldID
	
	"regionID" -> MetaFieldID
	
	"moduleID" -> PayloadID
	"metaID" -> PayloadID
	"regionID" -> PayloadID
	"connSource" -> PayloadID
	"connDest" -> PayloadID
	
	
	"enable"	-> MetaMethodRef
	"atPrimaryBorder" -> RegionMethodRef
	"atSecondaryBorder" -> RegionMethodRef
	
	"Main" 									-> SequencePrim
	"Choose" 								-> SequencePrim
	
	context-free syntax


	"@" ID "." ID									-> ModHolderRef{"ModHolderRef"}
	"@" ID 											-> ModHolderRef{"ModHolderRef"}
	"orientation" "matches" {OrientRef ","}* -> Exp{"OrientMatch"}
	
	
	MethodRef	"(" {Exp "," }* ")" ";"  -> Stmt{"FuncCall"}
	MethodRef 	"(" {Exp "," }* ")" 	 -> Exp{"FuncCall"}
	
		FuncRef  "(" {Exp "," }* ")" ";"	-> Stmt{"FuncCall"}
		FuncRef  "(" {Exp "," }* ")"   		-> Exp{"FuncCall"}
	FuncPrimRef "(" {Exp "," }* ")" ";"		-> Stmt{"FuncPrimCall"}
	FuncPrimRef "(" {Exp "," }* ")" 		-> Exp{"FuncPrimCall"}
	
	
	
	FuncPrimRef -> FuncRef{reject}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" StopCondition  -> Instr{"Instr",prefer}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" -> Instr{"Instr"}
	
	
	
	
	
	
	
	
	
	
	
	
	
	