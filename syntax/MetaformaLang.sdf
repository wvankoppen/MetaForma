module MetaformaLang

imports 
	Common
	MetaformaLang-Exp
	lexical/MetaformaLang-Identifiers

exports
	sorts MainDef Stmt Receive Sequence

  context-free start-symbols
  
    Start
 
  context-free syntax
  %% Declaration: In main program space
  %% MainDef: In all program space
  
   "package" ID Debug? MainDef*						-> Start {"Package"}
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Debug and visualisation
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    "debug" "{" ShowPackets? Visualize? "}" -> Debug{"Debug"}
    "show" "[" {PacketRef ","}* "]"	-> ShowPackets{"ShowPackets"}
    
    "visualize" "{" VisGroup*"}" -> Visualize {"Visualize"}
    ID "{" VisItem* "}" 		 -> VisGroup{"VisGroup"}
	ModHolderOrSeqRef ":" ColorRef ";" -> VisItem{"VisItem"}
    
    Color -> ColorRef{"Color"}
    
    ModHolderRef -> ModHolderOrSeqRef
    SequenceRef -> ModHolderOrSeqRef
    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Header
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	GroupDef 										-> MainDef

	"meta" "{" PartDecl? FieldDecl* FuncDecl* "}" 	-> MainDef{"Meta"}
	"module" "{" FieldDecl* FuncDecl* "}" 			-> MainDef{"Module"}
	"region" "{" BorderDecl? FuncDecl* "}" 			-> MainDef{"Region"}
	 
	Type ID "=" Exp									-> MainDef{"ConstDecl"}
	
	"borders" "[" BorderItem* "]"					-> BorderDecl{"BorderDecl"}
	
	Border ":" Exp ";" -> BorderItem{"BorderItem"}
	
	%% "left" 		-> Direction{"BorderLeft"}
	%% "right" 	-> Direction{"BorderRight"}
	%% "top" 		-> Direction{"BorderTop"} 
	%% "bottom" 	-> Direction{"BorderBottom"}  
	
	"meta" 							-> Meta{"Meta"}
	"module"						-> Module{"Module"}
	"region"						-> Region{"Region"}
	"config"						-> Config{"Config"}
	
	"void" ID "(" {ParamListElem ","}* ")" "{" VarDecl* Stmt* "}"					-> FuncDecl{"FuncDecl"}
	Type ID "(" {ParamListElem ","}* ")" "{" VarDecl* Stmt* "return" Exp ";" "}"	-> FuncDecl{"FuncDecl"}
	
	Type ID 			-> ParamListElem{"Param"}
	
	"packet" ID "{" PayloadDecl* "}" 					-> MainDef{"PacketDecl"}
	
	Type ID ";" 				-> VarDecl{"VarDecl"}
	Type ID "=" Exp ";"			-> VarDecl{"VarDecl"}
	Type ID ";" 				-> FieldDecl{"FieldDecl"}
	Type ID ";" 				-> PayloadDecl{"PayloadDecl"}
	PacketRef ID 				-> PacketVarDecl{"PacketVarDecl"}

	"part" "[" {MetaPart ","}* "]" ";" -> PartDecl{"MetaPartDecl"}
	ID 									-> MetaPart{"MetaPart"}
	
	
	"None" 								-> ID{reject}
	
	MetaPartNoneRef 					-> Exp{"MetaPartNoneRef"}
	
	ID 									-> Ref{"VarRef"}
	ID 									-> PayloadRef{"PayloadRef"}
	
	PayloadRef "=" Exp					-> AssignElem{"AssignElem"}
	{AssignElem ","}*					-> AssignList{"AssignList"} 
	
	"unicast" PacketRef "(" AssignList ")" "to" Nbs  ";" -> Stmt{"Unicast"}
	"receive" "(" PacketVarDecl ")" 	-> Receive{"Receive"}
	
	"sequence" ID "{" EvHdlr* EvHdlrSemi* VarDecl* FuncDecl*  Instr* "}" -> MainDef{"Sequence"}
	
	
	EvHdlr								 		 -> MainDef
	
	"when" "(" Receive ")" "{" VarDecl* Stmt* "}" -> EvHdlr{"EvHdlr"}
	
	
	"when" "(" EventExp ")" "{" VarDecl* Stmt* "}" 	-> EvHdlrSemi{"If"}
	"when" "{"Case* "}" 							-> EvHdlrSemi{"Ifs"}
	"case" Exp ":" Stmt* 							-> Case{"If"}
	
 		
	ID									-> PacketRef {"Packet"}
	PacketPrim							-> PacketRef {"PacketPrim"}
	PacketPrim	-> ID{reject}
	
	
	
	Exp 								-> EventExp
	"rate" Ref							-> Rate{"Rate"}
	

	Ref "=" Exp ";" 				-> Stmt{"Assign"}

	Stmt							-> Block{"Block"}
	"{" Stmt* "}" 							-> Block{"Block"}
		
	"if" "(" Exp ")" Block "else" Block 		-> Stmt{"IfElse"}
	
	"if" "(" Exp ")" Block 					-> Stmt{"If"}
			
		
	ID 										-> OrientRef{"OrientRef"}	
		
	Stmt -> Instr
	"goto" SequenceRef ";"							-> Stmt{"Goto"}
	"goto" SequenceRef OrientClause ";"							-> Stmt{"GotoOrient"}
	"orientating" OrientRef 				-> OrientClause{"Orientation"}
		
	"group" ID "[" {Mod ","}* "]" 			-> GroupDef{"Group"}
	"group" ID							-> GroupDef{"Group"}
	
	ID 								-> Mod{"Mod"}
	
	"try" "region" SequenceRef OrientClause? "from" {MetaFieldRef ","}*  "excluding" {MetaFieldRef ","}*  ";" -> Stmt{"TryRegion"}
	
	 {Exp ","}* 				-> ByteList {"ByteArr"}
	 ID 		-> MetaFieldRef {"MetaFieldRef"}
	 
	"break" ";"	-> Stmt{"Break"}
	
	lexical syntax
			
	"None"	-> MetaPartNoneRef
	"Packet" -> PacketPrim
	"Discover" -> PacketPrim
	"Consensus" -> PacketPrim
	"MetaVarSync" -> PacketPrim
	"Region" -> PacketPrim
	"Symmetry" -> PacketPrim

	context-free syntax
	Exp 			-> ModHolderOrExp
	ModHolderRef 	-> ModHolderOrExp
	
	"wait" "(" StopCondition ")" ";" -> InstrPost {"Wait"}
	"until" "(" StopCondition ")" ";" -> InstrPost{"Until"}
	
	"consensus" "(" ")" 	-> StopCondition {"Consensus"}
	Exp						-> StopCondition	
	
	
	ID -> FuncRef{"FuncRef"}
	
	SysObj "." ID 					-> MethodRef{"MethodRef"}
	Meta "." MetaMethodRef 		-> MethodRef{"MethodPrimRef"}
	Module "." ModuleMethodRef 		-> MethodRef{"MethodPrimRef"}
	Region "." RegionMethodRef 		-> MethodRef{"MethodPrimRef"}
	
	
	ID -> VarRef{"VarRef"}
	
	
	
	SequencePrim						-> SequenceRef{"SequencePrimRef",prefer}
	ID		 							-> SequenceRef{"SequenceRef"}
	
	%% Because we need to include SequenceName in the URI in NBL
	%% SequencePrim						-> SequenceName{"SequencePrimName",prefer}
	%% ID		 							-> SequenceName{"SequenceName"}
	%% 
	%% Oops: Constructors in de URI are not supported!

	
	
	Meta "." MetaFieldID 			-> Ref{"FieldPrimRef"}
	Module "." ModuleFieldID 		-> Ref{"FieldPrimRef"}
	Config "." ConfigFieldID 		-> Ref{"FieldPrimRef"}
	SysObj "." ID					-> Ref{"FieldRef"}
	
	PacketVarRef "." PayloadID 						-> Ref{"PayloadPrimRef"}
	PacketVarRef "." ID 						-> Ref{"PayloadRef"}
	VarRef 						-> PacketVarRef

	 
	ModuleFieldID 	-> ID{reject}
	MetaFieldID  	-> ID{reject}
	MetaMethodRef  	-> ID{reject}
	ModuleMethodRef -> ID{reject}
	RegionMethodRef -> ID{reject}
	PayloadID 		-> ID{reject}
	ConfigFieldID	-> ID{reject}
	
	lexical syntax
	"id" 		-> ModuleFieldID 
	%% "id" 		-> MetaFieldID
	"metaID" 	-> ModuleFieldID
	"group" 	-> ModuleFieldID
	"metaPart" 	-> ModuleFieldID
	
	"assignTime"-> ConfigFieldID
	"propagationTime"-> ConfigFieldID
	
	"id" 		-> MetaFieldID
	"regionID" 	-> MetaFieldID
	"size" 		-> MetaFieldID
	"sizeExtra" -> MetaFieldID
	%% "absorbed"	-> MetaFieldID
	
	"moduleID" 	-> PayloadID
	"metaID" 	-> PayloadID
	"regionID" 	-> PayloadID 
	"connSource"-> PayloadID
	"connDest" 	-> PayloadID
	
	"restoreID"			-> ModuleMethodRef
	"atBorder"			-> ModuleMethodRef
	"fixSymmetry"		-> ModuleMethodRef
	"proximity"			-> ModuleMethodRef
	"tiltX"				-> ModuleMethodRef
	"tiltY"				-> ModuleMethodRef
	"tiltZ"				-> ModuleMethodRef
	"initMeta"			-> ModuleMethodRef
	"storeID"			-> ModuleMethodRef
	"enable"			-> MetaMethodRef
	"finish" 			-> RegionMethodRef
	"release" 			-> RegionMethodRef
	"atPrimaryBorder" 	-> RegionMethodRef
	"atSecondaryBorder" -> RegionMethodRef
	"assignTime" 		-> ConfigFieldID
	
	
	"connect" 			-> FuncActuationRef
	"disconnect" 		-> FuncActuationRef
	"extend"			-> FuncActuationRef
	"extendSet"			-> FuncActuationRef
	"retract" 			-> FuncActuationRef
	"retractSet"		-> FuncActuationRef
	"rotate" 			-> FuncActuationRef
	"stop" 				-> FuncActuationRef
	"rotating"			-> FuncActuationRef
	"rotateAbsolute"	-> FuncActuationRef
	
	
	
	lexical syntax
	"Main" 									-> SequencePrim
	"Choose" 								-> SequencePrim
	
	context-free syntax

	"@" "X" "[" Exp "]"								-> ModHolderRef{"ModHolderPrimNumRef",prefer}
	"@" ID "[" Exp "]"								-> ModHolderRef{"ModHolderNumRef"}
	"@" ID "." ID									-> ModHolderRef{"ModHolderRef"}
	"@" ID 											-> ModHolderRef{"ModHolderRef"}
	"@X"											-> ModHolderRef{"ModHolderPrimRef"}
	
	"orientation" "matches" {OrientRef ","}* -> Exp{"OrientMatch"}
	
	
	MethodRef	"(" {Exp "," }* ")" ";"  -> Stmt{"FuncCall"}
	MethodRef 	"(" {Exp "," }* ")" 	 -> Exp{"FuncCall"}
	
		FuncRef  "(" {Exp "," }* ")" ";"	-> Stmt{"FuncCall"}
		FuncRef  "(" {Exp "," }* ")"   		-> Exp{"FuncCall"}
	FuncPrimRef2 "(" {Exp "," }* ")" ";"		-> Stmt{"FuncCall"}
	FuncPrimRef2 "(" {Exp "," }* ")" 		-> Exp{"FuncCall"}
	
	FuncPrimRef -> FuncPrimRef2{"FuncPrimRef"}
	FuncActuationRef -> FuncRef{"FuncActuationRef"}
	
	FuncPrimRef 	-> FuncRef{reject}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" InstrPost  -> Instr{"Instr",prefer}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" -> Instr{"Instr"}
	
	
	Border -> Exp
	BorderName -> Border{"Border"}
	BorderName -> ID{reject}
	
	lexical syntax
	"top" 		-> BorderName
	"bottom"	-> BorderName
	"left"		-> BorderName
	"right"		-> BorderName
	
	
	
	
	
	
	
	
	
	
	