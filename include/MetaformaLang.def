definition
module lexical/MetaformaLang-Identifiers
imports MetaformaLang

exports
	sorts Id String Time Obj
	
lexical syntax
	[a-zA-Z][a-zA-Z0-9\_]* -> ID
    [0-9]+          -> INT
    [0-9]+?[\.][0-9]+          -> FLOAT
	~[\"]*	-> String
	
lexical restrictions
	ID -/- [a-zA-Z0-9\_]
	String -/- ~[\"]
	
	

lexical syntax
	
	"if"			-> ID {reject}
	"else"			-> ID {reject}
	"for"			-> ID {reject}
	"while"			-> ID {reject}
	"wait"			-> ID {reject}
	"until"			-> ID {reject}
	"consensus"		-> ID {reject}
	"goto"			-> ID {reject}
	"when"			-> ID {reject}
	
	 
	 "red"			-> Color
	 "blue"			-> Color
	 "green"		-> Color
	 "yellow"		-> Color
	 "cyan"			-> Color
	 "white"		-> Color
	 "black"		-> Color
	 "gray"			-> Color
	 "orange"		-> Color
	 "magenta"		-> Color
	 "brown"		-> Color
	
	
	lexical syntax
	"false"			-> Bool
	"true"			-> Bool
	
	"MALE"			-> ConstLan
	"FEMALE"		-> ConstLan
	"WEST"			-> ConstLan
	"EAST"			-> ConstLan
	"NORTH"			-> ConstLan
	"SOUTH"			-> ConstLan
	"MAX_BYTE"		-> Const
	
	"isMALE"		-> FuncPrimRef
	"isFEMALE"		-> FuncPrimRef
	"isWEST"		-> FuncPrimRef
	"isEAST"		-> FuncPrimRef
	"isNORTH"		-> FuncPrimRef
	"isSOUTH"		-> FuncPrimRef
	"min"			-> FuncPrimRef
	"pow2"			-> FuncPrimRef
	

	
	
	
	"connect"		-> Core
	"disconnect"	-> Core
	"rotate"		-> Core
	"stop"			-> Core
	"rotate_continuous"	-> Core

	
	
	
	
	
	context-free syntax
	"null"			-> Exp{cons("Null")}
	"boolean"		-> Type{cons("Boolean")}
	"byte"			-> Type{cons("Byte")}
	"int"			-> Type{cons("Int")}
	"float"			-> Type{cons("Float")}
	"void"			-> Type{cons("Void")}
	"byte" "[" "]"	-> Type{cons("ByteArr")}
	
	"robot"			-> SysObj{cons("Robot")}
	"meta"			-> SysObj{cons("Meta")}
	"module"		-> SysObj{cons("Module")}
	"region"		-> SysObj{cons("Region")}
	"debug"			-> SysObj{cons("Debug")}
	"config"		-> SysObj{cons("Config")}

	"null"			-> ID {reject}
	 Const			-> ID {reject}
	 ConstLan		-> ID {reject}
	 Bool			-> ID {reject}
	 SysObj			-> ID {reject}
	 Core			-> ID {reject}

module Exp

imports Common
imports MetaformaLang
imports lexical/MetaformaLang-Identifiers

exports


  context-free syntax
	Ref		 				-> Exp
	"#(" NbsOp ")"			-> Exp{cons("NbsCount")}
	"$(" NbsOp ")"			-> Nbs{cons("Nbs")}
	{NbsFilter ","}*	-> NbsOp{cons("NbsOp")}
	NbsFilterKey ":" Exp 	-> NbsFilter{cons("NbsFilter")}
	ModHolderRef			-> NbsFilter{cons("NbsFilter")}
	
	lexical syntax
	"metaPart" 				-> NbsFilterKey
	"connected" 			-> NbsFilterKey
	"inRegion" 				-> NbsFilterKey
	"metaID" 				-> NbsFilterKey
	"connDest" 				-> NbsFilterKey
	"connSource"			-> NbsFilterKey
	
	 context-free syntax
	
	ID 						-> MetaPart{cons("MetaPart")}
	INT						-> Exp{cons("Int")}
	FLOAT					-> Exp{cons("Float")}
	Const					-> Exp{cons("Const")}
	ConstLan					-> Exp{cons("Const")}
	Bool					-> Exp{cons("Bool")}
	ModHolderRef				-> Exp
	"(" Exp ")"			    -> Exp{cons("Par")}
	"[" {Exp ","}* "]"		-> Exp{cons("ByteArr")}
	STRING					-> Exp{cons("String")}
	
	 
	
	Exp "%"	Exp					-> Exp{left,cons("Modulo")}
	"!" Exp 					-> Exp{right,cons("Not")}
	"-" Exp 					-> Exp{right,cons("Min")}
	Exp "-" Exp 				-> Exp{right,cons("Min")}
	Exp "*" Exp					-> Exp{left,cons("Mul")}
	Exp "/" Exp					-> Exp{left,cons("Div")}
	Exp "+" Exp					-> Exp{left,cons("Plus")}
	Exp "-" Exp					-> Exp{left,cons("Min")}
	Exp "<" Exp					-> Exp{left,cons("Lt")} 
    Exp ">" Exp					-> Exp{left,cons("Gt")}
    Exp "<=" Exp				-> Exp{left,cons("LtEq")}
    Exp ">=" Exp				-> Exp{left,cons("GtEq")}
    Exp "==" Exp				-> Exp{left,cons("Eq")} 
    Exp "!=" Exp				-> Exp{left,cons("Neq")} 
	Exp "&&" Exp				-> Exp{left,cons("And")}
	Exp "||" Exp				-> Exp{left,cons("Or")}
	Exp "&" Exp					-> Exp{left,cons("AndBit")}
	Exp "|" Exp					-> Exp{left,cons("OrBit")}
	
	context-free priorities
	{
		Exp "%"	Exp					-> Exp
	} > {right:
		"!" Exp 					-> Exp
	} > { left:
		Exp "*" Exp					-> Exp
		Exp "/" Exp					-> Exp
	} > { left:
		Exp "+" Exp					-> Exp
		Exp "-" Exp					-> Exp
	} > { non-assoc:
    	Exp "<" Exp					-> Exp
    	Exp ">" Exp					-> Exp
    	Exp "<=" Exp				-> Exp
    	Exp ">=" Exp				-> Exp
    	Exp "==" Exp				-> Exp
    	Exp "!=" Exp				-> Exp
	} > {left:
		Exp "&&" Exp				-> Exp
	} > {left:
		Exp "||" Exp				-> Exp
	} > {left:
		Exp "&" Exp					-> Exp
	} > {left:	
		Exp "|" Exp					-> Exp
	}

module MetaformaLang

imports 
	Common
	Exp
	lexical/MetaformaLang-Identifiers

exports

sorts	Group MetaClass RotateContinuous

  context-free start-symbols
  
    Start
 
  context-free syntax
  %% Definition:  INDIRECT code generation
  %% Declaration: DIRECT code generation
  
   "program" ID Debug? Definition* Declaration*						-> Start {cons("Program")}
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Debug and visualisation
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    "debug" "{" ShowPackets? Visualize? "}" -> Debug{cons("Debug")}
    "show" "[" {PacketRef ","}* "]" ";"	-> ShowPackets{cons("ShowPackets")}
    
    "visualize" "{" VisGroup*"}" -> Visualize {cons("Visualize")}
    ID "{" VisItem* "}" 		 -> VisGroup{cons("VisGroup")}
	ModHolderOrSeqRef ":" ColorRef ";" -> VisItem{cons("VisItem")}
    
    Color -> ColorRef{cons("Color")}
    
    ModHolderRef -> ModHolderOrSeqRef
    SequenceRef -> ModHolderOrSeqRef
    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Header
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	GroupDef 										-> Definition

	Meta "{" PartDecl? FieldDecl* FuncDecl* "}" 	-> Definition{cons("Class")}
	Module "{" FieldDecl* FuncDecl* "}" 			-> Definition{cons("Class")}
	Region "{" BorderDecl? FuncDecl* "}" 			-> Definition{cons("Class")}
	
	Type ID "=" Exp									-> Definition{cons("ConstDecl")}
	
	"borders" "[" BorderItem* "]"			-> BorderDecl{cons("BorderDecl")}
	
	Direction ":" Exp ";" -> BorderItem{cons("BorderItem")}
	
	"left" 		-> Direction{cons("BorderLeft")}
	"right" 	-> Direction{cons("BorderRight")}
	"top" 		-> Direction{cons("BorderTop")} 
	"bottom" 	-> Direction{cons("BorderBottom")}  
	
	"meta" 							-> Meta{cons("Meta")}
	"module"						-> Module{cons("Module")}
	"region"						-> Region{cons("Region")}
	"config"						-> Config{cons("Config")}
	
	"void" ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "}"					-> FuncDecl{cons("FuncDecl")}
	Type ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "return" Exp ";" "}"	-> FuncDecl{cons("FuncDecl")}
	
	Type ID 			-> ParamListElem{cons("Param")}
	
	"packet" ID "{" PayloadDecl* "}" 					-> Definition{cons("PacketDecl")}
	FuncDecl 											-> Declaration

	
	Type ID ";" 				-> VarDecl{cons("VarDecl")}
	Type ID ";" 				-> FieldDecl{cons("FieldDecl")}
	Type ID ";" 				-> PayloadDecl{cons("PayloadDecl")}
	PacketRef ID 				-> PacketVarDecl{cons("PacketVarDecl")}
	

	"part" "[" {MetaPart ","}* "]" ";" -> PartDecl{cons("MetaPartDecl")}
	ID 									-> MetaPart{cons("MetaPart")}
	
	
	"None" -> ID{reject}
	
	MetaPartNoneRef 					-> Exp{cons("MetaPartNoneRef")}
	
	ID 									-> Ref{cons("VarRef")}
	ID 									-> PayloadRef{cons("PayloadRef")}
	
	PayloadRef "=" Exp					-> AssignElem{cons("AssignElem")}
	{AssignElem ","}*					-> AssignList{cons("AssignList")} 
	%% "unicast" PacketRef "(" AssignList ")" "to" Nbs Rate? ";" -> Stmt{"Unicast"}
	"unicast" PacketRef "(" AssignList ")" "to" Nbs  ";" -> Stmt{cons("Unicast")}
	"receive" "(" PacketVarDecl ")" 	-> Receive{cons("Receive")}
	
	"sequence" ID "{" EvHdlr* EvHdlrSemi* VarDecl* FuncDecl*  Instr* "}" -> Declaration{cons("Sequence")}
	
	
	EvHdlr										 -> Definition
	"when" "(" Receive ")" "{" VarDecl* Stmt* "}" -> EvHdlr{cons("EvHdlr")}
	
	"when" "(" EventExp ")" "{" VarDecl* Stmt* "}" -> EvHdlrSemi{cons("If")}
 		
	ID									-> PacketRef {cons("Packet")}
	PacketPrim							-> PacketRef {cons("PacketPrim")}
	PacketPrim	-> ID{reject}
	
	
	
	Exp 								-> EventExp
	"rate" Ref							-> Rate{cons("Rate")}
	

	
	
	Ref "=" Exp ";" 				-> Stmt{cons("Assign")}
	
	

	Stmt							-> Block{cons("Block")}
	"{" Stmt* "}" 							-> Block{cons("Block")}
		
	"if" "(" Exp ")" Block "else" Block 		-> Stmt{cons("IfElse")}
	
	"if" "(" Exp ")" Block 					-> Stmt{cons("If")}
		
	
			
	
		
	ID 										-> OrientRef{cons("OrientRef")}	
		
	Stmt -> Instr
	"goto" SequenceRef ";"							-> Stmt{cons("Goto")}
	"goto" ID "orientating" ID ";"			-> Stmt{cons("Goto")}
	
	"group" ID "[" {Mod ","}* "]" 			-> GroupDef{cons("Group")}
	"group" ID							-> GroupDef{cons("Group")}
	
	ID 								-> Mod{cons("Mod")}
	
	"try" "region" SequenceRef "orientating" OrientRef "from" {MetaFieldRef ","}*  "excluding" {MetaFieldRef ","}*  ";" -> Stmt{cons("TryRegion")}
	
	 {Exp ","}* 				-> ByteList {cons("ByteArr")}
	 ID 		-> MetaFieldRef {cons("MetaFieldRef")}
	 

	
	Disconnect "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("Disconnect")}
	Connect "(" ModHolderRef "," Exp")" ";"			-> Stmt{cons("Connect")}
	Rotate "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("Rotate")}
	RotateContinuous "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("RotateCont")}

	
	Stop "(" ModHolderRef ")" ";"			-> Stmt{cons("Stop")}
	
	"break" ";"	-> Stmt{cons("Break")}
	
	lexical syntax
		
	%% We define these as lexical syntax such that Spoofax does not see it as a keyword and thus make it bold
		
	"stop" -> Stop
	"rotate_continuous" -> RotateContinuous	
	"rotate" -> Rotate
	"disconnect" -> Disconnect
	"connect" -> Connect
	
	"None"	-> MetaPartNoneRef
	"Packet" -> PacketPrim
	"Discover" -> PacketPrim
	"Consensus" -> PacketPrim
	"MetaVarSync" -> PacketPrim
	"Region" -> PacketPrim
	"Symmetry" -> PacketPrim

	context-free syntax
		
		
	
	Exp 			-> ModHolderOrExp
	ModHolderRef 	-> ModHolderOrExp
	
	"wait" "(" StopCondition ")" ";" -> InstrPost {cons("Wait")}
	"until" "(" StopCondition ")" ";" -> InstrPost{cons("Until")}
	
	"consensus" "(" ")" 	-> StopCondition {cons("Consensus")}
	Exp						-> StopCondition	
	
	
	ID -> FuncRef{cons("FuncRef")}
	
	SysObj "." ID 					-> MethodRef{cons("MethodRef")}
	Meta "." MetaMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	Module "." ModuleMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	Region "." RegionMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	
	
	ID -> VarRef{cons("VarRef")}
	
	
	
	SequencePrim						-> SequenceRef{cons("SequencePrimRef"),prefer}
	ID		 							-> SequenceRef{cons("SequenceRef")}
	
	%% Because we need to include SequenceName in the URI in NBL
	%% SequencePrim						-> SequenceName{"SequencePrimName",prefer}
	%% ID		 							-> SequenceName{"SequenceName"}
	%% 
	%% Oops: Constructors in de URI are not supported!

	
	
	
	Meta "." MetaFieldID 			-> Ref{cons("FieldPrimRef")}
	Module "." ModuleFieldID 		-> Ref{cons("FieldPrimRef")}
	Config "." ConfigFieldID 		-> Ref{cons("FieldPrimRef")}
	SysObj "." ID					-> Ref{cons("FieldRef")}
	
	PacketVarRef "." PayloadID 						-> Ref{cons("PayloadPrimRef")}
	PacketVarRef "." ID 						-> Ref{cons("PayloadRef")}
	VarRef 						-> PacketVarRef

	 
	ModuleFieldID 	-> ID{reject}
	MetaFieldID  	-> ID{reject}
	MetaMethodRef  	-> ID{reject}
	ModuleMethodRef -> ID{reject}
	RegionMethodRef -> ID{reject}
	PayloadID 		-> ID{reject}
	ConfigFieldID	-> ID{reject}
	
	lexical syntax
	"id" 		-> ModuleFieldID 
	%% "id" 		-> MetaFieldID
	"metaID" 	-> ModuleFieldID
	"group" 	-> ModuleFieldID
	"metaPart" 	-> ModuleFieldID
	
	"id" 		-> MetaFieldID
	"regionID" 	-> MetaFieldID
	"size" 		-> MetaFieldID
	
	"moduleID" 	-> PayloadID
	"metaID" 	-> PayloadID
	"regionID" 	-> PayloadID
	"connSource"-> PayloadID
	"connDest" 	-> PayloadID
	
	"proximity"			-> ModuleMethodRef
	"enable"			-> MetaMethodRef
	"create"			-> MetaMethodRef
	"finish" 			-> RegionMethodRef
	"atPrimaryBorder" 	-> RegionMethodRef
	"atSecondaryBorder" -> RegionMethodRef
	"assignTime" 		-> ConfigFieldID
	
	
	lexical syntax
	"Main" 									-> SequencePrim
	"Choose" 								-> SequencePrim
	
	context-free syntax


	"@" ID "." ID									-> ModHolderRef{cons("ModHolderRef")}
	"@" ID 											-> ModHolderRef{cons("ModHolderRef")}
	"@*"											-> ModHolderRef{cons("ModHolderAllRef")}
	
	"orientation" "matches" {OrientRef ","}* -> Exp{cons("OrientMatch")}
	
	
	MethodRef	"(" {Exp "," }* ")" ";"  -> Stmt{cons("FuncCall")}
	MethodRef 	"(" {Exp "," }* ")" 	 -> Exp{cons("FuncCall")}
	
		FuncRef  "(" {Exp "," }* ")" ";"	-> Stmt{cons("FuncCall")}
		FuncRef  "(" {Exp "," }* ")"   		-> Exp{cons("FuncCall")}
	FuncPrimRef2 "(" {Exp "," }* ")" ";"		-> Stmt{cons("FuncCall")}
	FuncPrimRef2 "(" {Exp "," }* ")" 		-> Exp{cons("FuncCall")}
	
	FuncPrimRef -> FuncPrimRef2{cons("FuncPrimRef")}
	
	
	FuncPrimRef 	-> FuncRef{reject}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" InstrPost  -> Instr{cons("Instr"),prefer}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" -> Instr{cons("Instr")}

module Common
imports MetaformaLang

exports

  lexical syntax
    
    "\"" StringChar* "\"" -> STRING
    ~[\"\n]               -> StringChar
    "\\\""                -> StringChar
    BackSlashChar         -> StringChar
    "\\"                  -> BackSlashChar
    
    [\ \t\n\r] -> LAYOUT
    
    [\*]                             -> CommentChar
    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
    
    -> EOF
  
  lexical restrictions
  
    %% Ensure greedy matching for lexicals
  
    CommentChar   -/- [\/]
    INT           -/- [0-9]
    ID            -/- [a-zA-Z0-9\_]
    
    %% EOF may not be followed by any char
    
    EOF           -/- ~[]

    %% Backslash chars in strings may not be followed by " 
    
    BackSlashChar -/- [\"]

  context-free restrictions
  
    %% Ensure greedy matching for comments

    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\/]
    LAYOUT? -/- [\/].[\*]

module MetaformaLang

imports 
	Common
	Exp
	lexical/MetaformaLang-Identifiers

exports

sorts	Group MetaClass RotateContinuous

  context-free start-symbols
  
    Start
 
  context-free syntax
  %% Definition:  INDIRECT code generation
  %% Declaration: DIRECT code generation
  
   "program" ID Debug? Definition* Declaration*						-> Start {cons("Program")}
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Debug and visualisation
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    "debug" "{" ShowPackets? Visualize? "}" -> Debug{cons("Debug")}
    "show" "[" {PacketRef ","}* "]" ";"	-> ShowPackets{cons("ShowPackets")}
    
    "visualize" "{" VisGroup*"}" -> Visualize {cons("Visualize")}
    ID "{" VisItem* "}" 		 -> VisGroup{cons("VisGroup")}
	ModHolderOrSeqRef ":" ColorRef ";" -> VisItem{cons("VisItem")}
    
    Color -> ColorRef{cons("Color")}
    
    ModHolderRef -> ModHolderOrSeqRef
    SequenceRef -> ModHolderOrSeqRef
    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Header
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	GroupDef 										-> Definition

	Meta "{" PartDecl? FieldDecl* FuncDecl* "}" 	-> Definition{cons("Class")}
	Module "{" FieldDecl* FuncDecl* "}" 			-> Definition{cons("Class")}
	Region "{" BorderDecl? FuncDecl* "}" 			-> Definition{cons("Class")}
	
	Type ID "=" Exp									-> Definition{cons("ConstDecl")}
	
	"borders" "[" BorderItem* "]"			-> BorderDecl{cons("BorderDecl")}
	
	Direction ":" Exp ";" -> BorderItem{cons("BorderItem")}
	
	"left" 		-> Direction{cons("BorderLeft")}
	"right" 	-> Direction{cons("BorderRight")}
	"top" 		-> Direction{cons("BorderTop")} 
	"bottom" 	-> Direction{cons("BorderBottom")}  
	
	"meta" 							-> Meta{cons("Meta")}
	"module"						-> Module{cons("Module")}
	"region"						-> Region{cons("Region")}
	"config"						-> Config{cons("Config")}
	
	"void" ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "}"					-> FuncDecl{cons("FuncDecl")}
	Type ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "return" Exp ";" "}"	-> FuncDecl{cons("FuncDecl")}
	
	Type ID 			-> ParamListElem{cons("Param")}
	
	"packet" ID "{" PayloadDecl* "}" 					-> Definition{cons("PacketDecl")}
	FuncDecl 											-> Declaration

	
	Type ID ";" 				-> VarDecl{cons("VarDecl")}
	Type ID ";" 				-> FieldDecl{cons("FieldDecl")}
	Type ID ";" 				-> PayloadDecl{cons("PayloadDecl")}
	PacketRef ID 				-> PacketVarDecl{cons("PacketVarDecl")}
	

	"part" "[" {MetaPart ","}* "]" ";" -> PartDecl{cons("MetaPartDecl")}
	ID 									-> MetaPart{cons("MetaPart")}
	
	
	"None" -> ID{reject}
	
	MetaPartNoneRef 					-> Exp{cons("MetaPartNoneRef")}
	
	ID 									-> Ref{cons("VarRef")}
	ID 									-> PayloadRef{cons("PayloadRef")}
	
	PayloadRef "=" Exp					-> AssignElem{cons("AssignElem")}
	{AssignElem ","}*					-> AssignList{cons("AssignList")} 
	%% "unicast" PacketRef "(" AssignList ")" "to" Nbs Rate? ";" -> Stmt{"Unicast"}
	"unicast" PacketRef "(" AssignList ")" "to" Nbs  ";" -> Stmt{cons("Unicast")}
	"receive" "(" PacketVarDecl ")" 	-> Receive{cons("Receive")}
	
	"sequence" ID "{" EvHdlr* EvHdlrSemi* VarDecl* FuncDecl*  Instr* "}" -> Declaration{cons("Sequence")}
	
	
	EvHdlr										 -> Definition
	"when" "(" Receive ")" "{" VarDecl* Stmt* "}" -> EvHdlr{cons("EvHdlr")}
	
	"when" "(" EventExp ")" "{" VarDecl* Stmt* "}" -> EvHdlrSemi{cons("If")}
 		
	ID									-> PacketRef {cons("Packet")}
	PacketPrim							-> PacketRef {cons("PacketPrim")}
	PacketPrim	-> ID{reject}
	
	
	
	Exp 								-> EventExp
	"rate" Ref							-> Rate{cons("Rate")}
	

	
	
	Ref "=" Exp ";" 				-> Stmt{cons("Assign")}
	
	

	Stmt							-> Block{cons("Block")}
	"{" Stmt* "}" 							-> Block{cons("Block")}
		
	"if" "(" Exp ")" Block "else" Block 		-> Stmt{cons("IfElse")}
	
	"if" "(" Exp ")" Block 					-> Stmt{cons("If")}
		
	
			
	
		
	ID 										-> OrientRef{cons("OrientRef")}	
		
	Stmt -> Instr
	"goto" SequenceRef ";"							-> Stmt{cons("Goto")}
	"goto" ID "orientating" ID ";"			-> Stmt{cons("Goto")}
	
	"group" ID "[" {Mod ","}* "]" 			-> GroupDef{cons("Group")}
	"group" ID							-> GroupDef{cons("Group")}
	
	ID 								-> Mod{cons("Mod")}
	
	"try" "region" SequenceRef "orientating" OrientRef "from" {MetaFieldRef ","}*  "excluding" {MetaFieldRef ","}*  ";" -> Stmt{cons("TryRegion")}
	
	 {Exp ","}* 				-> ByteList {cons("ByteArr")}
	 ID 		-> MetaFieldRef {cons("MetaFieldRef")}
	 

	
	Disconnect "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("Disconnect")}
	Connect "(" ModHolderRef "," Exp")" ";"			-> Stmt{cons("Connect")}
	Rotate "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("Rotate")}
	RotateContinuous "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("RotateCont")}

	
	Stop "(" ModHolderRef ")" ";"			-> Stmt{cons("Stop")}
	
	"break" ";"	-> Stmt{cons("Break")}
	
	lexical syntax
		
	%% We define these as lexical syntax such that Spoofax does not see it as a keyword and thus make it bold
		
	"stop" -> Stop
	"rotate_continuous" -> RotateContinuous	
	"rotate" -> Rotate
	"disconnect" -> Disconnect
	"connect" -> Connect
	
	"None"	-> MetaPartNoneRef
	"Packet" -> PacketPrim
	"Discover" -> PacketPrim
	"Consensus" -> PacketPrim
	"MetaVarSync" -> PacketPrim
	"Region" -> PacketPrim
	"Symmetry" -> PacketPrim

	context-free syntax
		
		
	
	Exp 			-> ModHolderOrExp
	ModHolderRef 	-> ModHolderOrExp
	
	"wait" "(" StopCondition ")" ";" -> InstrPost {cons("Wait")}
	"until" "(" StopCondition ")" ";" -> InstrPost{cons("Until")}
	
	"consensus" "(" ")" 	-> StopCondition {cons("Consensus")}
	Exp						-> StopCondition	
	
	
	ID -> FuncRef{cons("FuncRef")}
	
	SysObj "." ID 					-> MethodRef{cons("MethodRef")}
	Meta "." MetaMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	Module "." ModuleMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	Region "." RegionMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	
	
	ID -> VarRef{cons("VarRef")}
	
	
	
	SequencePrim						-> SequenceRef{cons("SequencePrimRef"),prefer}
	ID		 							-> SequenceRef{cons("SequenceRef")}
	
	%% Because we need to include SequenceName in the URI in NBL
	%% SequencePrim						-> SequenceName{"SequencePrimName",prefer}
	%% ID		 							-> SequenceName{"SequenceName"}
	%% 
	%% Oops: Constructors in de URI are not supported!

	
	
	
	Meta "." MetaFieldID 			-> Ref{cons("FieldPrimRef")}
	Module "." ModuleFieldID 		-> Ref{cons("FieldPrimRef")}
	Config "." ConfigFieldID 		-> Ref{cons("FieldPrimRef")}
	SysObj "." ID					-> Ref{cons("FieldRef")}
	
	PacketVarRef "." PayloadID 						-> Ref{cons("PayloadPrimRef")}
	PacketVarRef "." ID 						-> Ref{cons("PayloadRef")}
	VarRef 						-> PacketVarRef

	 
	ModuleFieldID 	-> ID{reject}
	MetaFieldID  	-> ID{reject}
	MetaMethodRef  	-> ID{reject}
	ModuleMethodRef -> ID{reject}
	RegionMethodRef -> ID{reject}
	PayloadID 		-> ID{reject}
	ConfigFieldID	-> ID{reject}
	
	lexical syntax
	"id" 		-> ModuleFieldID 
	%% "id" 		-> MetaFieldID
	"metaID" 	-> ModuleFieldID
	"group" 	-> ModuleFieldID
	"metaPart" 	-> ModuleFieldID
	
	"id" 		-> MetaFieldID
	"regionID" 	-> MetaFieldID
	"size" 		-> MetaFieldID
	
	"moduleID" 	-> PayloadID
	"metaID" 	-> PayloadID
	"regionID" 	-> PayloadID
	"connSource"-> PayloadID
	"connDest" 	-> PayloadID
	
	"proximity"			-> ModuleMethodRef
	"enable"			-> MetaMethodRef
	"create"			-> MetaMethodRef
	"finish" 			-> RegionMethodRef
	"atPrimaryBorder" 	-> RegionMethodRef
	"atSecondaryBorder" -> RegionMethodRef
	"assignTime" 		-> ConfigFieldID
	
	
	lexical syntax
	"Main" 									-> SequencePrim
	"Choose" 								-> SequencePrim
	
	context-free syntax


	"@" ID "." ID									-> ModHolderRef{cons("ModHolderRef")}
	"@" ID 											-> ModHolderRef{cons("ModHolderRef")}
	"@*"											-> ModHolderRef{cons("ModHolderAllRef")}
	
	"orientation" "matches" {OrientRef ","}* -> Exp{cons("OrientMatch")}
	
	
	MethodRef	"(" {Exp "," }* ")" ";"  -> Stmt{cons("FuncCall")}
	MethodRef 	"(" {Exp "," }* ")" 	 -> Exp{cons("FuncCall")}
	
		FuncRef  "(" {Exp "," }* ")" ";"	-> Stmt{cons("FuncCall")}
		FuncRef  "(" {Exp "," }* ")"   		-> Exp{cons("FuncCall")}
	FuncPrimRef2 "(" {Exp "," }* ")" ";"		-> Stmt{cons("FuncCall")}
	FuncPrimRef2 "(" {Exp "," }* ")" 		-> Exp{cons("FuncCall")}
	
	FuncPrimRef -> FuncPrimRef2{cons("FuncPrimRef")}
	
	
	FuncPrimRef 	-> FuncRef{reject}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" InstrPost  -> Instr{cons("Instr"),prefer}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" -> Instr{cons("Instr")}