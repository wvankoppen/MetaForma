definition
module lexical/MetaformaLang-Identifiers
imports MetaformaLang

exports
	sorts Id String Time Obj
	
lexical syntax
	[a-zA-Z][a-zA-Z0-9\_]* -> ID
    [0-9]+          -> INT
	~[\"]*	-> String
	
lexical restrictions
	ID -/- [a-zA-Z0-9\_]
	"var" -/- [a-zA-Z0-9\_]
	String -/- ~[\"]
	
	

lexical syntax
	
	"if"			-> ID {reject}
	"else"			-> ID {reject}
	"for"			-> ID {reject}
	"while"			-> ID {reject}
	"wait"			-> ID {reject}
	"until"			-> ID {reject}
	"consensus"		-> ID {reject}
	"goto"			-> ID {reject}
	"when"			-> ID {reject}
	
	 
	 "red"			-> Color
	 "blue"			-> Color
	 "green"		-> Color
	 "yellow"		-> Color
	 "cyan"		-> Color
	
	
	
	"false"			-> Bool
	"true"			-> Bool
	
	"MALE"			-> ConstLan
	"FEMALE"		-> ConstLan
	"WEST"			-> ConstLan
	"EAST"			-> ConstLan
	"NORTH"			-> ConstLan
	"SOUTH"			-> ConstLan
	"MAX_BYTE"		-> Const
	"null"			-> Const

	
	
	
	
	
	"connect"		-> Core
	"disconnect"	-> Core
	"rotate"		-> Core
	"stop"			-> Core
	"rotate_continuous"	-> Core
	"disconnect_part"	-> Core
	"connect_part"	-> Core
	
	
	
	
	
	context-free syntax
	"boolean"		-> Type{cons("Boolean")}
	"byte"			-> Type{cons("Byte")}
	"void"			-> Type{cons("Void")}
	"byte" "[" "]"	-> Type{cons("ByteArr")}
	
	"meta"			-> SysObj{cons("Meta")}
	"module"		-> SysObj{cons("Module")}
	"region"		-> SysObj{cons("Region")}
	"debug"			-> SysObj{cons("Debug")}
	"config"		-> SysObj{cons("Config")}
	"config"		-> SysObj{cons("Config")}
	
	 Const			-> ID {reject}
	 ConstLan		-> ID {reject}
	 Bool			-> ID {reject}
	 SysObj			-> ID {reject}
	 Core			-> ID {reject}

module Exp

imports Common
imports MetaformaLang
imports lexical/MetaformaLang-Identifiers

exports


  context-free syntax
	Ref		 				-> Exp
	"#(" NbsOp ")"			-> Exp{cons("NbsCount")}
	"$(" NbsOp ")"			-> Nbs{cons("Nbs")}
%%	"!$(" NbsOp ")"			-> Exp{"NbsNone"}
	{NbsFilter ","}+	-> NbsOp{cons("NbsOp")}
	%% ConnFilter						-> NbsOp{"NbsOp"}
	%% {NbsFilter ","}+				-> NbsOp{"NbsOp"}
	%% Exp 					-> ConnFilter{"ConnFilter"}
	%% Exp "->" Exp			-> ConnFilter{"ConnFilter"}
	
	NbsFilterKey ":" Exp -> NbsFilter{cons("NbsFilter")}
	lexical syntax
	"metaPart" 				-> NbsFilterKey
	"connected" 			-> NbsFilterKey
	"inRegion" 				-> NbsFilterKey
	"metaID" 				-> NbsFilterKey
	"connDest" 				-> NbsFilterKey
	"connSource"			-> NbsFilterKey
	ModHolderRef			-> NbsFilterElem
	 context-free syntax
	
	ID 						-> MetaPart{cons("MetaPart")}
	INT						-> Exp{cons("Int")}
	Const					-> Exp{cons("Const")}
	ConstLan					-> Exp{cons("Const")}
	Bool					-> Exp{cons("Bool")}
	ModHolderRef				-> Exp
	"(" Exp ")"			    -> Exp{cons("Par")}
	"[" {Exp ","}* "]"		-> Exp{cons("ByteArr")}
	STRING					-> Exp{cons("String")}
	
	 
	
	Exp "%"	Exp					-> Exp{left,cons("Mod")}
	"!" Exp 					-> Exp{right,cons("Not")}
	"-" Exp 					-> Exp{right,cons("Min")}
	Exp "-" Exp 				-> Exp{right,cons("Min")}
	Exp "*" Exp					-> Exp{left,cons("Mul")}
	Exp "/" Exp					-> Exp{left,cons("Div")}
	Exp "+" Exp					-> Exp{left,cons("Plus")}
	Exp "-" Exp					-> Exp{left,cons("Min")}
	Exp "<" Exp					-> Exp{left,cons("Lt")} 
    Exp ">" Exp					-> Exp{left,cons("Gt")}
    Exp "<=" Exp				-> Exp{left,cons("LtEq")}
    Exp ">=" Exp				-> Exp{left,cons("GtEq")}
    Exp "==" Exp				-> Exp{left,cons("Eq")} 
    Exp "!=" Exp				-> Exp{left,cons("Neq")} 
	Exp "&&" Exp				-> Exp{left,cons("And")}
	Exp "||" Exp				-> Exp{left,cons("Or")}
	Exp "&" Exp					-> Exp{left,cons("AndBit")}
	Exp "|" Exp					-> Exp{left,cons("OrBit")}
	
	context-free priorities
	{
		Exp "%"	Exp					-> Exp
	} > {right:
		"!" Exp 					-> Exp
	} > { left:
		Exp "*" Exp					-> Exp
		Exp "/" Exp					-> Exp
	} > { left:
		Exp "+" Exp					-> Exp
		Exp "-" Exp					-> Exp
	} > { non-assoc:
    	Exp "<" Exp					-> Exp
    	Exp ">" Exp					-> Exp
    	Exp "<=" Exp				-> Exp
    	Exp ">=" Exp				-> Exp
    	Exp "==" Exp				-> Exp
    	Exp "!=" Exp				-> Exp
	} > {left:
		Exp "&&" Exp				-> Exp
	} > {left:
		Exp "||" Exp				-> Exp
	} > {left:
		Exp "&" Exp					-> Exp
	} > {left:	
		Exp "|" Exp					-> Exp
	}

module MetaformaLang

imports 
	Common
	Exp
	lexical/MetaformaLang-Identifiers

exports

sorts	Group MetaClass

  context-free start-symbols
  
    Start
 
  context-free syntax
  %% Definition:  INDIRECT code generation
  %% Declaration: DIRECT code generation
  
   "program" ID Visualize? Definition* Declaration*						-> Start {cons("Program")}
   %%ModuleDef GroupDef* Definition 						-> Start {"Start", scope(Include)}
    
    %% Declaration -> Definition
    
    "visualize" "{" VisGroup*"}" -> Visualize {cons("Visualize")}
    ID "{" VisItem* "}" 		 -> VisGroup{cons("VisGroup")}
	
	ModHolderOrStateRef ":" Color [0-9] ";" -> VisItem{cons("VisItem")}
    
    ModHolderRef -> ModHolderOrStateRef
    StateRef -> ModHolderOrStateRef
    
	GroupDef 										-> Definition
	Meta "{" FieldOrPartDecl* FuncDecl* "}" 	-> Definition{cons("Class")}
	Module "{" FieldDecl* FuncDecl* "}" 			-> Definition{cons("Class")}
	
	"meta" 							-> Meta{cons("Meta")}
	"module"						-> Module{cons("Module")}
	
	"void" ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "}"					-> FuncDecl{cons("FuncDecl")}
	Type ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "return" Exp ";" "}"	-> FuncDecl{cons("FuncDecl")}
	
	Type ID 			-> ParamListElem{cons("Param")}
	ID					-> Type{avoid}
	
	"packet" ID "{" PayloadDecl* "}" 					-> Definition{cons("Packet")}
	FuncDecl -> Declaration

	
	%%Type {ID ","}+ ";" -> VarDecl{"VarDecl"}
	Type ID ";" -> VarDecl{cons("VarDecl")}
	Type ID ";" -> FieldDecl{cons("FieldDecl")}
	Type ID ";" -> PayloadDecl{cons("PayloadDecl")}
	PacketRef ID -> PacketVarDecl{cons("VarDecl")}
	
	FieldDecl -> FieldOrPartDecl
	"part" "[" {MetaPart ","}* "]" ";" -> FieldOrPartDecl{cons("MetaPartDecl")}
	ID 		-> MetaPart{cons("MetaPart")}
	
	ID 					-> Ref{cons("VarRef")}
	ID 					-> PayloadRef{cons("PayloadRef")}
	
	PayloadRef "=" ID			-> AssignElem{cons("AssignElem")}
	{AssignElem ","}*				-> AssignList{cons("AssignList")} 
	
	"sequence" ID "{" EvHdlr* VarDecl* FuncDecl*  Instr* "}" -> Declaration{cons("State")}
	%% "state" ID "{" EvHdlr*EvHdlr ->  TryReg* "}" -> Definition{"State"}
	
	
	EvHdlr										 -> Definition
	"when" "(" Event ")" "{" VarDecl* Stmt* "}" -> EvHdlr{cons("EvHdlr")}
	

	
	ID								-> PacketRef {cons("PacketRef")}
	
	"receive" "(" PacketVarDecl ")" 	-> Event{cons("Receive")}
	Exp 							-> Event{cons("Event")}
	"rate" Ref						-> Rate{cons("Rate")}
	
	
	%% "to" "meta-module" -> DestSingle{"Meta"}
	%% "on" "connector" -> DestSingle{"Conn"}
	%% "to" "meta-modules" -> DestMulti{"Meta"}
	%% "on" "connectors" -> DestMulti{"Conn"}
	%% "in" "region" -> DestMulti{"Region"}
	
	
	"unicast" PacketRef "(" AssignList ")" "to" Nbs Rate? ";" -> Stmt{cons("Unicast")}
	"broadcast" PacketRef "(" AssignList ")" Rate? ";" -> Stmt{cons("Broadcast")}
	
	
	Ref "=" Exp ";" -> Stmt{cons("Assign")}
	
	

	Stmt							-> Block{cons("Block")}
	"{" Stmt* "}" 							-> Block{cons("Block")}
		
	"if" "(" Exp ")" Block "else" Block 		-> Stmt{cons("IfElse")}
	
	"if" "(" Exp ")" Block 					-> Stmt{cons("If")}
		
	ID 										-> StateRef{cons("StateRef")}
	ID 										-> OrientRef{cons("OrientRef")}	
		
	Stmt -> Instr
	"goto" StateRef ";"							-> Stmt{cons("Goto")}
	"goto" ID "orientating" ID ";"			-> Stmt{cons("Goto")}
	
	"group" ID "[" {Mod ","}* "]" 			-> GroupDef{cons("Group")}
	"group" ID							-> GroupDef{cons("GroupNum")}
	
	ID 								-> Mod{cons("Mod")}
	
	"try" "region" StateRef "orientating" OrientRef "from" ByteList "excluding" ByteList ";" -> Stmt{cons("TryRegion")}
	
	 {Exp ","}* 				-> ByteList {cons("ByteArr")}
	
	"disconnect" "(" ModHolderRef "," ModHolderRef ")" ";"			-> Stmt{cons("Disconnect")}
	"connect" "(" ModHolderRef "," ModHolderRef ")" ";"			-> Stmt{cons("Connect")}
	"rotate" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("Rotate")}
	"rotate_continuous" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("RotateCont")}
	"disconnect_part" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("DisconnectPart")}
	"connect_part" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("ConnectPart")}
	
	"stop" "(" ModHolderRef ")" ";"			-> Stmt{cons("Stop")}
	
	%% "for" "(" Type ID ":" ID")" Block				-> Stmt{"For"}
	
	
	
	
	"wait" "(" Stop ")" ";" -> StopCondition {cons("Wait")}
	"until" "(" Stop ")" ";" -> StopCondition{cons("Until")}
	
	"consensus" "(" ")" 	-> Stop {cons("Consensus")}
	Exp						-> Stop	
	
	
	ID -> FuncRef{cons("FuncRef")}
	
	Obj "." ID -> MethodRef{cons("MethodRef")}
	
	
	"orientation" "matches" {OrientRef ","}* -> Exp{cons("OrientMatch")}
	
	
	 "@" ID "." ID									-> ModHolderRef{cons("ModHolderRef")}
	"@" ID 											-> ModHolderRef{cons("ModHolderRef")}
	
	Obj "." ID 			-> Ref{cons("FieldRef")}
	
	ID -> Obj{cons("ObjRef")}
	SysObj -> Obj	

	%% context-free priorities
	%% {
	%% "@" ID										-> ModHolderRef{"ModHolderRef"}
	%% } > {
	%% ID "@" ID									-> ModHolderRef{"ModHolderRef"}
	%% }
	%% 
	
	context-free priorities
	{
	"do" "{" Definition* Declaration* Stmt* "}" StopCondition  -> Instr{cons("Instr")}
	} > {
	"do" "{" Definition* Declaration* Stmt* "}" -> Instr{cons("Instr")}
	}
	
	
	context-free priorities
	{
	MethodRef	"(" {Exp "," }* ")" ";"  -> Stmt{cons("FuncCall")}
	MethodRef 	"(" {Exp "," }* ")" 	 -> Exp{cons("FuncCall")}
	} > {
	FuncRef  "(" {Exp "," }* ")"   			-> Exp{cons("FuncCall")}
	FuncRef  "(" {Exp "," }* ")" ";"			-> Stmt{cons("FuncCall")}
	}

module Common
imports MetaformaLang

exports

  lexical syntax
  
  	[0-9]+ "ms"			-> TIME
  
    
    
    "\"" StringChar* "\"" -> STRING
    ~[\"\n]               -> StringChar
    "\\\""                -> StringChar
    BackSlashChar         -> StringChar
    "\\"                  -> BackSlashChar
    
    [\ \t\n\r] -> LAYOUT
    
    [\*]                             -> CommentChar
    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
    
    -> EOF
  
  lexical restrictions
  
    %% Ensure greedy matching for lexicals
  
    CommentChar   -/- [\/]
    INT           -/- [0-9]
    ID            -/- [a-zA-Z0-9\_]
    
    %% EOF may not be followed by any char
    
    EOF           -/- ~[]

    %% Backslash chars in strings may not be followed by " 
    
    BackSlashChar -/- [\"]

  context-free restrictions
  
    %% Ensure greedy matching for comments

    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\/]
    LAYOUT? -/- [\/].[\*]

module MetaformaLang

imports 
	Common
	Exp
	lexical/MetaformaLang-Identifiers

exports

sorts	Group MetaClass

  context-free start-symbols
  
    Start
 
  context-free syntax
  %% Definition:  INDIRECT code generation
  %% Declaration: DIRECT code generation
  
   "program" ID Visualize? Definition* Declaration*						-> Start {cons("Program")}
   %%ModuleDef GroupDef* Definition 						-> Start {"Start", scope(Include)}
    
    %% Declaration -> Definition
    
    "visualize" "{" VisGroup*"}" -> Visualize {cons("Visualize")}
    ID "{" VisItem* "}" 		 -> VisGroup{cons("VisGroup")}
	
	ModHolderOrStateRef ":" Color [0-9] ";" -> VisItem{cons("VisItem")}
    
    ModHolderRef -> ModHolderOrStateRef
    StateRef -> ModHolderOrStateRef
    
	GroupDef 										-> Definition
	Meta "{" FieldOrPartDecl* FuncDecl* "}" 	-> Definition{cons("Class")}
	Module "{" FieldDecl* FuncDecl* "}" 			-> Definition{cons("Class")}
	
	"meta" 							-> Meta{cons("Meta")}
	"module"						-> Module{cons("Module")}
	
	"void" ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "}"					-> FuncDecl{cons("FuncDecl")}
	Type ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "return" Exp ";" "}"	-> FuncDecl{cons("FuncDecl")}
	
	Type ID 			-> ParamListElem{cons("Param")}
	ID					-> Type{avoid}
	
	"packet" ID "{" PayloadDecl* "}" 					-> Definition{cons("Packet")}
	FuncDecl -> Declaration

	
	%%Type {ID ","}+ ";" -> VarDecl{"VarDecl"}
	Type ID ";" -> VarDecl{cons("VarDecl")}
	Type ID ";" -> FieldDecl{cons("FieldDecl")}
	Type ID ";" -> PayloadDecl{cons("PayloadDecl")}
	PacketRef ID -> PacketVarDecl{cons("VarDecl")}
	
	FieldDecl -> FieldOrPartDecl
	"part" "[" {MetaPart ","}* "]" ";" -> FieldOrPartDecl{cons("MetaPartDecl")}
	ID 		-> MetaPart{cons("MetaPart")}
	
	ID 					-> Ref{cons("VarRef")}
	ID 					-> PayloadRef{cons("PayloadRef")}
	
	PayloadRef "=" ID			-> AssignElem{cons("AssignElem")}
	{AssignElem ","}*				-> AssignList{cons("AssignList")} 
	
	"sequence" ID "{" EvHdlr* VarDecl* FuncDecl*  Instr* "}" -> Declaration{cons("State")}
	%% "state" ID "{" EvHdlr*EvHdlr ->  TryReg* "}" -> Definition{"State"}
	
	
	EvHdlr										 -> Definition
	"when" "(" Event ")" "{" VarDecl* Stmt* "}" -> EvHdlr{cons("EvHdlr")}
	

	
	ID								-> PacketRef {cons("PacketRef")}
	
	"receive" "(" PacketVarDecl ")" 	-> Event{cons("Receive")}
	Exp 							-> Event{cons("Event")}
	"rate" Ref						-> Rate{cons("Rate")}
	
	
	%% "to" "meta-module" -> DestSingle{"Meta"}
	%% "on" "connector" -> DestSingle{"Conn"}
	%% "to" "meta-modules" -> DestMulti{"Meta"}
	%% "on" "connectors" -> DestMulti{"Conn"}
	%% "in" "region" -> DestMulti{"Region"}
	
	
	"unicast" PacketRef "(" AssignList ")" "to" Nbs Rate? ";" -> Stmt{cons("Unicast")}
	"broadcast" PacketRef "(" AssignList ")" Rate? ";" -> Stmt{cons("Broadcast")}
	
	
	Ref "=" Exp ";" -> Stmt{cons("Assign")}
	
	

	Stmt							-> Block{cons("Block")}
	"{" Stmt* "}" 							-> Block{cons("Block")}
		
	"if" "(" Exp ")" Block "else" Block 		-> Stmt{cons("IfElse")}
	
	"if" "(" Exp ")" Block 					-> Stmt{cons("If")}
		
	ID 										-> StateRef{cons("StateRef")}
	ID 										-> OrientRef{cons("OrientRef")}	
		
	Stmt -> Instr
	"goto" StateRef ";"							-> Stmt{cons("Goto")}
	"goto" ID "orientating" ID ";"			-> Stmt{cons("Goto")}
	
	"group" ID "[" {Mod ","}* "]" 			-> GroupDef{cons("Group")}
	"group" ID							-> GroupDef{cons("GroupNum")}
	
	ID 								-> Mod{cons("Mod")}
	
	"try" "region" StateRef "orientating" OrientRef "from" ByteList "excluding" ByteList ";" -> Stmt{cons("TryRegion")}
	
	 {Exp ","}* 				-> ByteList {cons("ByteArr")}
	
	"disconnect" "(" ModHolderRef "," ModHolderRef ")" ";"			-> Stmt{cons("Disconnect")}
	"connect" "(" ModHolderRef "," ModHolderRef ")" ";"			-> Stmt{cons("Connect")}
	"rotate" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("Rotate")}
	"rotate_continuous" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("RotateCont")}
	"disconnect_part" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("DisconnectPart")}
	"connect_part" "(" ModHolderRef "," Exp ")" ";"			-> Stmt{cons("ConnectPart")}
	
	"stop" "(" ModHolderRef ")" ";"			-> Stmt{cons("Stop")}
	
	%% "for" "(" Type ID ":" ID")" Block				-> Stmt{"For"}
	
	
	
	
	"wait" "(" Stop ")" ";" -> StopCondition {cons("Wait")}
	"until" "(" Stop ")" ";" -> StopCondition{cons("Until")}
	
	"consensus" "(" ")" 	-> Stop {cons("Consensus")}
	Exp						-> Stop	
	
	
	ID -> FuncRef{cons("FuncRef")}
	
	Obj "." ID -> MethodRef{cons("MethodRef")}
	
	
	"orientation" "matches" {OrientRef ","}* -> Exp{cons("OrientMatch")}
	
	
	 "@" ID "." ID									-> ModHolderRef{cons("ModHolderRef")}
	"@" ID 											-> ModHolderRef{cons("ModHolderRef")}
	
	Obj "." ID 			-> Ref{cons("FieldRef")}
	
	ID -> Obj{cons("ObjRef")}
	SysObj -> Obj	

	%% context-free priorities
	%% {
	%% "@" ID										-> ModHolderRef{"ModHolderRef"}
	%% } > {
	%% ID "@" ID									-> ModHolderRef{"ModHolderRef"}
	%% }
	%% 
	
	context-free priorities
	{
	"do" "{" Definition* Declaration* Stmt* "}" StopCondition  -> Instr{cons("Instr")}
	} > {
	"do" "{" Definition* Declaration* Stmt* "}" -> Instr{cons("Instr")}
	}
	
	
	context-free priorities
	{
	MethodRef	"(" {Exp "," }* ")" ";"  -> Stmt{cons("FuncCall")}
	MethodRef 	"(" {Exp "," }* ")" 	 -> Exp{cons("FuncCall")}
	} > {
	FuncRef  "(" {Exp "," }* ")"   			-> Exp{cons("FuncCall")}
	FuncRef  "(" {Exp "," }* ")" ";"			-> Stmt{cons("FuncCall")}
	}