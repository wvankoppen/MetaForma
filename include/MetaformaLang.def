definition
module lexical/MetaformaLang-Identifiers
imports MetaformaLang

exports
	sorts Id String Time Obj
	
lexical syntax
	[a-zA-Z][a-zA-Z0-9\_]* -> ID
    [0-9]+          -> INT
    [0-9]+?[\.][0-9]+          -> FLOAT
	~[\"]*	-> String
	
lexical restrictions
	ID -/- [a-zA-Z0-9\_]
	String -/- ~[\"]
	
	
lexical syntax
	"if"			-> ID {reject}
	"else"			-> ID {reject}
	"for"			-> ID {reject}
	"while"			-> ID {reject}
	"wait"			-> ID {reject}
	"until"			-> ID {reject}
	"consensus"		-> ID {reject}
	"goto"			-> ID {reject}
	"when"			-> ID {reject}
	"null"			-> ID {reject}
	 
	 "red"			-> Color
	 "blue"			-> Color
	 "green"		-> Color
	 "yellow"		-> Color
	 "cyan"			-> Color
	 "white"		-> Color
	 "black"		-> Color
	 "gray"			-> Color
	 "orange"		-> Color
	 "magenta"		-> Color
	 "pink"			-> Color
	
	"false"			-> Bool
	"true"			-> Bool
	
	"MALE"			-> ConstLan
	"FEMALE"		-> ConstLan
	"WEST"			-> ConstLan
	"EAST"			-> ConstLan
	"NORTH"			-> ConstLan
	"SOUTH"			-> ConstLan
	"MAX_BYTE"		-> ConstLan
	
	"isMALE"		-> FuncPrimRef
	"isFEMALE"		-> FuncPrimRef
	"isWEST"		-> FuncPrimRef
	"isEAST"		-> FuncPrimRef
	"isNORTH"		-> FuncPrimRef
	"isSOUTH"		-> FuncPrimRef
	"min"			-> FuncPrimRef
	"pow2"			-> FuncPrimRef
	"mirror"		-> FuncPrimRef
	
	FuncActuationRef	-> ID {reject}
	
	
	
	
	context-free syntax
	"null"			-> Exp{cons("Null")}
	"boolean"		-> Type{cons("Boolean")}
	"byte"			-> Type{cons("Byte")}
	"int"			-> Type{cons("Int")}
	"float"			-> Type{cons("Float")}
	"void"			-> Type{cons("Void")}
	"byte" "[" "]"	-> Type{cons("ByteArr")}
	
	"robot"			-> SysObj{cons("Robot")}
	"meta"			-> SysObj{cons("Meta")}
	"module"		-> SysObj{cons("Module")}
	"region"		-> SysObj{cons("Region")}
	"debug"			-> SysObj{cons("Debug")}
	"config"		-> SysObj{cons("Config")}

	
	 %%Const			-> ID {reject} is the same as constlan?
	 ConstLan		-> ID {reject}
	 Bool			-> ID {reject}
	 SysObj			-> ID {reject}

module MetaformaLang-Exp

imports Common
imports MetaformaLang
imports lexical/MetaformaLang-Identifiers

exports


  context-free syntax
	Ref		 				-> Exp
	"#(" NbsOp ")"			-> Exp{cons("NbsCount")}
	"$(" NbsOp ")"			-> Nbs{cons("Nbs")}
	{NbsFilter ","}*		-> NbsOp{cons("NbsOp")}
	NbsFilterKey ":" Exp 	-> NbsFilter{cons("NbsFilter")}
	ModHolderRef			-> NbsFilter{cons("NbsFilter")}
	
	lexical syntax
	"metaPart" 				-> NbsFilterKey
	"connected" 			-> NbsFilterKey
	"inRegion" 				-> NbsFilterKey
	"metaID" 				-> NbsFilterKey
	"connDest" 				-> NbsFilterKey
	"connSource"			-> NbsFilterKey
	
	 context-free syntax
	
	ID 						-> MetaPart{cons("MetaPart")}
	INT						-> Exp{cons("Int")}
	FLOAT					-> Exp{cons("Float")}
	Const					-> Exp{cons("Const")}
	ConstLan				-> Exp{cons("Const")}
	Bool					-> Exp{cons("Bool")}
	ModHolderRef			-> Exp
	"(" Exp ")"			    -> Exp{cons("Par")}
	"[" {Exp ","}* "]"		-> Exp{cons("ByteArr")}
	STRING					-> Exp{cons("String")}
	
	
	Exp "%"	Exp					-> Exp{left,cons("Modulo")}
	"!" Exp 					-> Exp{right,cons("Not")}
	"-" Exp 					-> Exp{right,cons("Min")}
	Exp "-" Exp 				-> Exp{right,cons("Min")}
	Exp "*" Exp					-> Exp{left,cons("Mul")}
	Exp "/" Exp					-> Exp{left,cons("Div")}
	Exp "+" Exp					-> Exp{left,cons("Plus")}
	Exp "-" Exp					-> Exp{left,cons("Min")}
	Exp "<" Exp					-> Exp{left,cons("Lt")} 
    Exp ">" Exp					-> Exp{left,cons("Gt")}
    Exp "<=" Exp				-> Exp{left,cons("LtEq")}
    Exp ">=" Exp				-> Exp{left,cons("GtEq")}
    Exp "==" Exp				-> Exp{left,cons("Eq")} 
    Exp "!=" Exp				-> Exp{left,cons("Neq")} 
	Exp "&&" Exp				-> Exp{left,cons("And")}
	Exp "||" Exp				-> Exp{left,cons("Or")}
	Exp "&" Exp					-> Exp{left,cons("AndBit")}
	Exp "|" Exp					-> Exp{left,cons("OrBit")}
	
	context-free priorities
	{
		Exp "%"	Exp					-> Exp
	} > {right:
		"!" Exp 					-> Exp
	} > { left:
		Exp "*" Exp					-> Exp
		Exp "/" Exp					-> Exp
	} > { left:
		Exp "+" Exp					-> Exp
		Exp "-" Exp					-> Exp
	} > { non-assoc:
    	Exp "<" Exp					-> Exp
    	Exp ">" Exp					-> Exp
    	Exp "<=" Exp				-> Exp
    	Exp ">=" Exp				-> Exp
    	Exp "==" Exp				-> Exp
    	Exp "!=" Exp				-> Exp
	} > {left:
		Exp "&&" Exp				-> Exp
	} > {left:
		Exp "||" Exp				-> Exp
	} > {left:
		Exp "&" Exp					-> Exp
	} > {left:	
		Exp "|" Exp					-> Exp
	}

module MetaformaLang

imports 
	Common
	MetaformaLang-Exp
	lexical/MetaformaLang-Identifiers

exports
	sorts MainDef Stmt Receive Sequence

  context-free start-symbols
  
    Start
 
  context-free syntax
  %% Declaration: In main program space
  %% MainDef: In all program space
  
   "package" ID Debug? MainDef*						-> Start {cons("Package")}
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Debug and visualisation
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    "debug" "{" ShowPackets? Visualize? "}" -> Debug{cons("Debug")}
    "show" "[" {PacketRef ","}* "]"	-> ShowPackets{cons("ShowPackets")}
    
    "visualize" "{" VisGroup*"}" -> Visualize {cons("Visualize")}
    ID "{" VisItem* "}" 		 -> VisGroup{cons("VisGroup")}
	ModHolderOrSeqRef ":" ColorRef ";" -> VisItem{cons("VisItem")}
    
    Color -> ColorRef{cons("Color")}
    
    ModHolderRef -> ModHolderOrSeqRef
    SequenceRef -> ModHolderOrSeqRef
    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Header
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	GroupDef 										-> MainDef

	"meta" "{" PartDecl? FieldDecl* FuncDecl* "}" 	-> MainDef{cons("Meta")}
	"module" "{" FieldDecl* FuncDecl* "}" 			-> MainDef{cons("Module")}
	"region" "{" BorderDecl? FuncDecl* "}" 			-> MainDef{cons("Region")}
	 
	Type ID "=" Exp									-> MainDef{cons("ConstDecl")}
	
	"borders" "[" BorderItem* "]"					-> BorderDecl{cons("BorderDecl")}
	
	Border ":" Exp ";" -> BorderItem{cons("BorderItem")}
	
	%% "left" 		-> Direction{"BorderLeft"}
	%% "right" 	-> Direction{"BorderRight"}
	%% "top" 		-> Direction{"BorderTop"} 
	%% "bottom" 	-> Direction{"BorderBottom"}  
	
	"meta" 							-> Meta{cons("Meta")}
	"module"						-> Module{cons("Module")}
	"region"						-> Region{cons("Region")}
	"config"						-> Config{cons("Config")}
	
	"void" ID "(" {ParamListElem ","}* ")" "{" VarDecl* Stmt* "}"					-> FuncDecl{cons("FuncDecl")}
	Type ID "(" {ParamListElem ","}* ")" "{" VarDecl* Stmt* "return" Exp ";" "}"	-> FuncDecl{cons("FuncDecl")}
	
	Type ID 			-> ParamListElem{cons("Param")}
	
	"packet" ID "{" PayloadDecl* "}" 					-> MainDef{cons("PacketDecl")}
	
	Type ID ";" 				-> VarDecl{cons("VarDecl")}
	Type ID "=" Exp ";"			-> VarDecl{cons("VarDecl")}
	Type ID ";" 				-> FieldDecl{cons("FieldDecl")}
	Type ID ";" 				-> PayloadDecl{cons("PayloadDecl")}
	PacketRef ID 				-> PacketVarDecl{cons("PacketVarDecl")}

	"part" "[" {MetaPart ","}* "]" ";" -> PartDecl{cons("MetaPartDecl")}
	ID 									-> MetaPart{cons("MetaPart")}
	
	
	"None" 								-> ID{reject}
	
	MetaPartNoneRef 					-> Exp{cons("MetaPartNoneRef")}
	
	ID 									-> Ref{cons("VarRef")}
	ID 									-> PayloadRef{cons("PayloadRef")}
	
	PayloadRef "=" Exp					-> AssignElem{cons("AssignElem")}
	{AssignElem ","}*					-> AssignList{cons("AssignList")} 
	
	"unicast" PacketRef "(" AssignList ")" "to" Nbs  ";" -> Stmt{cons("Unicast")}
	"receive" "(" PacketVarDecl ")" 	-> Receive{cons("Receive")}
	
	"sequence" ID "{" EvHdlr* EvHdlrSemi* VarDecl* FuncDecl*  Instr* "}" -> MainDef{cons("Sequence")}
	"strategy" "{" Stmt* "}" -> MainDef{cons("Strategy")}	
	
	"strategy;"	-> Stmt{cons("StrategyRef")}
	
	EvHdlr								 		 -> MainDef
	
	"when" "(" Receive ")" "{" VarDecl* Stmt* "}" -> EvHdlr{cons("EvHdlr")}
	
	
	"when" "(" EventExp ")" "{" VarDecl* Stmt* "}" 	-> EvHdlrSemi{cons("If")}
	"when" "{"Case* "}" 							-> EvHdlrSemi{cons("Ifs")}
	"case" Exp ":" Stmt* 							-> Case{cons("If")}
	
 		
	ID									-> PacketRef {cons("Packet")}
	PacketPrim							-> PacketRef {cons("PacketPrim")}
	PacketPrim	-> ID{reject}
	
	
	
	Exp 								-> EventExp
	"rate" Ref							-> Rate{cons("Rate")}
	

	Ref "=" Exp ";" 				-> Stmt{cons("Assign")}

	Stmt							-> Block{cons("Block")}
	"{" Stmt* "}" 							-> Block{cons("Block")}
		
	"if" "(" Exp ")" Block "else" Block 		-> Stmt{cons("IfElse")}
	
	"if" "(" Exp ")" Block 					-> Stmt{cons("If")}
			
		
	Orient 										-> OrientRef{cons("OrientRef")}	
		
	Orient -> ID{reject}	
		
	Stmt -> Instr
	"execute" SequenceRef ";"							-> Stmt{cons("Goto")}
	"execute" SequenceRef OrientClause ";"							-> Stmt{cons("GotoOrient")}
	"orienting" OrientRef 				-> OrientClause{cons("Orientation")}
		
	"group" ID "[" {Mod ","}* "]" 			-> GroupDef{cons("Group")}
	"group" ID							-> GroupDef{cons("Group")}
	
	ID 								-> Mod{cons("Mod")}
	
	"try" "region" SequenceRef OrientClause? "including" {MetaFieldRef ","}*  ExcludingClause?  ";" -> Stmt{cons("TryRegion")}
	
	"excluding" {MetaFieldRef ","}* -> ExcludingClause{cons("Excluding")}
	
	 {Exp ","}* 				-> ByteList {cons("ByteArr")}
	 ID 						-> MetaFieldRef {cons("MetaFieldRef")}
	 
	"break" ";"	-> Stmt{cons("Break")}
	
	lexical syntax
	
	"LEFT_BOTTOM"	-> Orient
	"LEFT_TOP"	-> Orient
	
	"RIGHT_BOTTOM"	-> Orient
	"RIGHT_TOP"	-> Orient
	
	"BOTTOM_LEFT"	-> Orient
	"BOTTOM_RIGHT"	-> Orient
	
	"TOP_LEFT"	-> Orient
	"TOP_RIGHT"	-> Orient

			
	"None"	-> MetaPartNoneRef
	"Packet" -> PacketPrim
	"Discover" -> PacketPrim
	"Consensus" -> PacketPrim
	"MetaVarSync" -> PacketPrim
	"Region" -> PacketPrim
	"Symmetry" -> PacketPrim

	context-free syntax
	Exp 			-> ModHolderOrExp
	ModHolderRef 	-> ModHolderOrExp
	
	"wait" "(" StopCondition ")" ";" -> InstrPost {cons("Wait")}
	"until" "(" StopCondition ")" ";" -> InstrPost{cons("Until")}
	
	"consensus" "(" ")" 	-> StopCondition {cons("Consensus")}
	Exp						-> StopCondition	
	
	
	ID -> FuncRef{cons("FuncRef")}
	
	SysObj "." ID 					-> MethodRef{cons("MethodRef")}
	Meta "." MetaMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	Module "." ModuleMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	Region "." RegionMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	
	
	ID -> VarRef{cons("VarRef")}
	
	
	
	SequencePrim						-> SequenceRef{cons("SequencePrimRef"),prefer}
	ID		 							-> SequenceRef{cons("SequenceRef")}
	
	%% Because we need to include SequenceName in the URI in NBL
	%% SequencePrim						-> SequenceName{"SequencePrimName",prefer}
	%% ID		 							-> SequenceName{"SequenceName"}
	%% 
	%% Oops: Constructors in de URI are not supported!

	
	
	Meta "." MetaFieldID 			-> Ref{cons("FieldPrimRef")}
	Module "." ModuleFieldID 		-> Ref{cons("FieldPrimRef")}
	Config "." ConfigFieldID 		-> Ref{cons("FieldPrimRef")}
	SysObj "." ID					-> Ref{cons("FieldRef")}
	
	PacketVarRef "." PayloadID 						-> Ref{cons("PayloadPrimRef")}
	PacketVarRef "." ID 						-> Ref{cons("PayloadRef")}
	VarRef 						-> PacketVarRef

	 
	ModuleFieldID 	-> ID{reject}
	MetaFieldID  	-> ID{reject}
	MetaMethodRef  	-> ID{reject}
	ModuleMethodRef -> ID{reject}
	RegionMethodRef -> ID{reject}
	PayloadID 		-> ID{reject}
	ConfigFieldID	-> ID{reject}
	
	lexical syntax
	"id" 		-> ModuleFieldID 
	%% "id" 		-> MetaFieldID
	"metaID" 	-> ModuleFieldID
	"group" 	-> ModuleFieldID
	"metaPart" 	-> ModuleFieldID
	
	"assignTime"-> ConfigFieldID
	"propagationTime"-> ConfigFieldID
	
	"id" 		-> MetaFieldID
	"regionID" 	-> MetaFieldID
	"size" 		-> MetaFieldID
	"sizeExtra" -> MetaFieldID
	%% "absorbed"	-> MetaFieldID
	
	"moduleID" 	-> PayloadID
	"metaID" 	-> PayloadID
	"regionID" 	-> PayloadID 
	"connSource"-> PayloadID
	"connDest" 	-> PayloadID
	
	"restoreID"			-> ModuleMethodRef
	"restoreSymmetry"	-> ModuleMethodRef
	"atBorder"			-> ModuleMethodRef
	"fixSymmetry"		-> ModuleMethodRef
	"proximity"			-> ModuleMethodRef
	"tiltX"				-> ModuleMethodRef
	"tiltY"				-> ModuleMethodRef
	"tiltZ"				-> ModuleMethodRef
	"initMeta"			-> ModuleMethodRef
	"backupID"			-> ModuleMethodRef
	"enable"			-> MetaMethodRef
	"finish" 			-> RegionMethodRef
	
	"finish" 			-> MetaMethodRef	%% Experimental
	
	"release" 			-> RegionMethodRef
	"atPrimaryBorder" 	-> RegionMethodRef
	"atSecondaryBorder" -> RegionMethodRef
	"assignTime" 		-> ConfigFieldID
	
	
	"connect" 			-> FuncActuationRef
	"disconnect" 		-> FuncActuationRef
	"extend"			-> FuncActuationRef
	"extendSet"			-> FuncActuationRef
	"retract" 			-> FuncActuationRef
	"retractSet"		-> FuncActuationRef
	"rotate" 			-> FuncActuationRef
	"stop" 				-> FuncActuationRef
	"rotating"			-> FuncActuationRef
	"rotateAbsolute"	-> FuncActuationRef
	
	
	
	lexical syntax
	"Main" 									-> SequencePrim
	"Choose" 								-> SequencePrim
	
	context-free syntax

	"@" "X" "[" Exp "]"								-> ModHolderRef{cons("ModHolderPrimNumRef"),prefer}
	"@" ID "[" Exp "]"								-> ModHolderRef{cons("ModHolderNumRef")}
	"@" ID "." ID									-> ModHolderRef{cons("ModHolderRef")}
	"@" ID 											-> ModHolderRef{cons("ModHolderRef")}
	"@X"											-> ModHolderRef{cons("ModHolderPrimRef"),prefer}
	
	"orientation" "matches" {OrientRef ","}* -> Exp{cons("OrientMatch")}
	
	
	MethodRef	"(" {Exp "," }* ")" ";"  -> Stmt{cons("FuncCall")}
	MethodRef 	"(" {Exp "," }* ")" 	 -> Exp{cons("FuncCall")}
	
		FuncRef  "(" {Exp "," }* ")" ";"	-> Stmt{cons("FuncCall")}
		FuncRef  "(" {Exp "," }* ")"   		-> Exp{cons("FuncCall")}
	FuncPrimRef2 "(" {Exp "," }* ")" ";"		-> Stmt{cons("FuncCall")}
	FuncPrimRef2 "(" {Exp "," }* ")" 		-> Exp{cons("FuncCall")}
	
	FuncPrimRef -> FuncPrimRef2{cons("FuncPrimRef")}
	FuncActuationRef -> FuncRef{cons("FuncActuationRef")}
	
	FuncPrimRef 	-> FuncRef{reject}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" InstrPost  -> Instr{cons("Instr"),prefer}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" -> Instr{cons("Instr")}
	
	
	Border -> Exp
	BorderName -> Border{cons("Border")}
	BorderName -> ID{reject}
	
	lexical syntax
	"TOP" 		-> BorderName
	"BOTTOM"	-> BorderName
	"LEFT"		-> BorderName
	"RIGHT"		-> BorderName
	
	
	
	
	
	
	
	
	
	
	

module Common
imports MetaformaLang

exports

  lexical syntax
    
    "\"" StringChar* "\"" -> STRING
    ~[\"\n]               -> StringChar
    "\\\""                -> StringChar
    BackSlashChar         -> StringChar
    "\\"                  -> BackSlashChar
    
    [\ \t\n\r] -> LAYOUT
    
    [\*]                             -> CommentChar
    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
    
    -> EOF
  
  lexical restrictions
  
    %% Ensure greedy matching for lexicals
  
    CommentChar   -/- [\/]
    INT           -/- [0-9]
    ID            -/- [a-zA-Z0-9\_]
    
    %% EOF may not be followed by any char
    
    EOF           -/- ~[]

    %% Backslash chars in strings may not be followed by " 
    
    BackSlashChar -/- [\"]

  context-free restrictions
  
    %% Ensure greedy matching for comments

    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\/]
    LAYOUT? -/- [\/].[\*]

module MetaformaLang

imports 
	Common
	MetaformaLang-Exp
	lexical/MetaformaLang-Identifiers

exports
	sorts MainDef Stmt Receive Sequence

  context-free start-symbols
  
    Start
 
  context-free syntax
  %% Declaration: In main program space
  %% MainDef: In all program space
  
   "package" ID Debug? MainDef*						-> Start {cons("Package")}
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Debug and visualisation
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    
    "debug" "{" ShowPackets? Visualize? "}" -> Debug{cons("Debug")}
    "show" "[" {PacketRef ","}* "]"	-> ShowPackets{cons("ShowPackets")}
    
    "visualize" "{" VisGroup*"}" -> Visualize {cons("Visualize")}
    ID "{" VisItem* "}" 		 -> VisGroup{cons("VisGroup")}
	ModHolderOrSeqRef ":" ColorRef ";" -> VisItem{cons("VisItem")}
    
    Color -> ColorRef{cons("Color")}
    
    ModHolderRef -> ModHolderOrSeqRef
    SequenceRef -> ModHolderOrSeqRef
    
    
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %% Header
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	GroupDef 										-> MainDef

	"meta" "{" PartDecl? FieldDecl* FuncDecl* "}" 	-> MainDef{cons("Meta")}
	"module" "{" FieldDecl* FuncDecl* "}" 			-> MainDef{cons("Module")}
	"region" "{" BorderDecl? FuncDecl* "}" 			-> MainDef{cons("Region")}
	 
	Type ID "=" Exp									-> MainDef{cons("ConstDecl")}
	
	"borders" "[" BorderItem* "]"					-> BorderDecl{cons("BorderDecl")}
	
	Border ":" Exp ";" -> BorderItem{cons("BorderItem")}
	
	%% "left" 		-> Direction{"BorderLeft"}
	%% "right" 	-> Direction{"BorderRight"}
	%% "top" 		-> Direction{"BorderTop"} 
	%% "bottom" 	-> Direction{"BorderBottom"}  
	
	"meta" 							-> Meta{cons("Meta")}
	"module"						-> Module{cons("Module")}
	"region"						-> Region{cons("Region")}
	"config"						-> Config{cons("Config")}
	
	"void" ID "(" {ParamListElem ","}* ")" "{" VarDecl* Stmt* "}"					-> FuncDecl{cons("FuncDecl")}
	Type ID "(" {ParamListElem ","}* ")" "{" VarDecl* Stmt* "return" Exp ";" "}"	-> FuncDecl{cons("FuncDecl")}
	
	Type ID 			-> ParamListElem{cons("Param")}
	
	"packet" ID "{" PayloadDecl* "}" 					-> MainDef{cons("PacketDecl")}
	
	Type ID ";" 				-> VarDecl{cons("VarDecl")}
	Type ID "=" Exp ";"			-> VarDecl{cons("VarDecl")}
	Type ID ";" 				-> FieldDecl{cons("FieldDecl")}
	Type ID ";" 				-> PayloadDecl{cons("PayloadDecl")}
	PacketRef ID 				-> PacketVarDecl{cons("PacketVarDecl")}

	"part" "[" {MetaPart ","}* "]" ";" -> PartDecl{cons("MetaPartDecl")}
	ID 									-> MetaPart{cons("MetaPart")}
	
	
	"None" 								-> ID{reject}
	
	MetaPartNoneRef 					-> Exp{cons("MetaPartNoneRef")}
	
	ID 									-> Ref{cons("VarRef")}
	ID 									-> PayloadRef{cons("PayloadRef")}
	
	PayloadRef "=" Exp					-> AssignElem{cons("AssignElem")}
	{AssignElem ","}*					-> AssignList{cons("AssignList")} 
	
	"unicast" PacketRef "(" AssignList ")" "to" Nbs  ";" -> Stmt{cons("Unicast")}
	"receive" "(" PacketVarDecl ")" 	-> Receive{cons("Receive")}
	
	"sequence" ID "{" EvHdlr* EvHdlrSemi* VarDecl* FuncDecl*  Instr* "}" -> MainDef{cons("Sequence")}
	"strategy" "{" Stmt* "}" -> MainDef{cons("Strategy")}	
	
	"strategy;"	-> Stmt{cons("StrategyRef")}
	
	EvHdlr								 		 -> MainDef
	
	"when" "(" Receive ")" "{" VarDecl* Stmt* "}" -> EvHdlr{cons("EvHdlr")}
	
	
	"when" "(" EventExp ")" "{" VarDecl* Stmt* "}" 	-> EvHdlrSemi{cons("If")}
	"when" "{"Case* "}" 							-> EvHdlrSemi{cons("Ifs")}
	"case" Exp ":" Stmt* 							-> Case{cons("If")}
	
 		
	ID									-> PacketRef {cons("Packet")}
	PacketPrim							-> PacketRef {cons("PacketPrim")}
	PacketPrim	-> ID{reject}
	
	
	
	Exp 								-> EventExp
	"rate" Ref							-> Rate{cons("Rate")}
	

	Ref "=" Exp ";" 				-> Stmt{cons("Assign")}

	Stmt							-> Block{cons("Block")}
	"{" Stmt* "}" 							-> Block{cons("Block")}
		
	"if" "(" Exp ")" Block "else" Block 		-> Stmt{cons("IfElse")}
	
	"if" "(" Exp ")" Block 					-> Stmt{cons("If")}
			
		
	Orient 										-> OrientRef{cons("OrientRef")}	
		
	Orient -> ID{reject}	
		
	Stmt -> Instr
	"execute" SequenceRef ";"							-> Stmt{cons("Goto")}
	"execute" SequenceRef OrientClause ";"							-> Stmt{cons("GotoOrient")}
	"orienting" OrientRef 				-> OrientClause{cons("Orientation")}
		
	"group" ID "[" {Mod ","}* "]" 			-> GroupDef{cons("Group")}
	"group" ID							-> GroupDef{cons("Group")}
	
	ID 								-> Mod{cons("Mod")}
	
	"try" "region" SequenceRef OrientClause? "including" {MetaFieldRef ","}*  ExcludingClause?  ";" -> Stmt{cons("TryRegion")}
	
	"excluding" {MetaFieldRef ","}* -> ExcludingClause{cons("Excluding")}
	
	 {Exp ","}* 				-> ByteList {cons("ByteArr")}
	 ID 						-> MetaFieldRef {cons("MetaFieldRef")}
	 
	"break" ";"	-> Stmt{cons("Break")}
	
	lexical syntax
	
	"LEFT_BOTTOM"	-> Orient
	"LEFT_TOP"	-> Orient
	
	"RIGHT_BOTTOM"	-> Orient
	"RIGHT_TOP"	-> Orient
	
	"BOTTOM_LEFT"	-> Orient
	"BOTTOM_RIGHT"	-> Orient
	
	"TOP_LEFT"	-> Orient
	"TOP_RIGHT"	-> Orient

			
	"None"	-> MetaPartNoneRef
	"Packet" -> PacketPrim
	"Discover" -> PacketPrim
	"Consensus" -> PacketPrim
	"MetaVarSync" -> PacketPrim
	"Region" -> PacketPrim
	"Symmetry" -> PacketPrim

	context-free syntax
	Exp 			-> ModHolderOrExp
	ModHolderRef 	-> ModHolderOrExp
	
	"wait" "(" StopCondition ")" ";" -> InstrPost {cons("Wait")}
	"until" "(" StopCondition ")" ";" -> InstrPost{cons("Until")}
	
	"consensus" "(" ")" 	-> StopCondition {cons("Consensus")}
	Exp						-> StopCondition	
	
	
	ID -> FuncRef{cons("FuncRef")}
	
	SysObj "." ID 					-> MethodRef{cons("MethodRef")}
	Meta "." MetaMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	Module "." ModuleMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	Region "." RegionMethodRef 		-> MethodRef{cons("MethodPrimRef")}
	
	
	ID -> VarRef{cons("VarRef")}
	
	
	
	SequencePrim						-> SequenceRef{cons("SequencePrimRef"),prefer}
	ID		 							-> SequenceRef{cons("SequenceRef")}
	
	%% Because we need to include SequenceName in the URI in NBL
	%% SequencePrim						-> SequenceName{"SequencePrimName",prefer}
	%% ID		 							-> SequenceName{"SequenceName"}
	%% 
	%% Oops: Constructors in de URI are not supported!

	
	
	Meta "." MetaFieldID 			-> Ref{cons("FieldPrimRef")}
	Module "." ModuleFieldID 		-> Ref{cons("FieldPrimRef")}
	Config "." ConfigFieldID 		-> Ref{cons("FieldPrimRef")}
	SysObj "." ID					-> Ref{cons("FieldRef")}
	
	PacketVarRef "." PayloadID 						-> Ref{cons("PayloadPrimRef")}
	PacketVarRef "." ID 						-> Ref{cons("PayloadRef")}
	VarRef 						-> PacketVarRef

	 
	ModuleFieldID 	-> ID{reject}
	MetaFieldID  	-> ID{reject}
	MetaMethodRef  	-> ID{reject}
	ModuleMethodRef -> ID{reject}
	RegionMethodRef -> ID{reject}
	PayloadID 		-> ID{reject}
	ConfigFieldID	-> ID{reject}
	
	lexical syntax
	"id" 		-> ModuleFieldID 
	%% "id" 		-> MetaFieldID
	"metaID" 	-> ModuleFieldID
	"group" 	-> ModuleFieldID
	"metaPart" 	-> ModuleFieldID
	
	"assignTime"-> ConfigFieldID
	"propagationTime"-> ConfigFieldID
	
	"id" 		-> MetaFieldID
	"regionID" 	-> MetaFieldID
	"size" 		-> MetaFieldID
	"sizeExtra" -> MetaFieldID
	%% "absorbed"	-> MetaFieldID
	
	"moduleID" 	-> PayloadID
	"metaID" 	-> PayloadID
	"regionID" 	-> PayloadID 
	"connSource"-> PayloadID
	"connDest" 	-> PayloadID
	
	"restoreID"			-> ModuleMethodRef
	"restoreSymmetry"	-> ModuleMethodRef
	"atBorder"			-> ModuleMethodRef
	"fixSymmetry"		-> ModuleMethodRef
	"proximity"			-> ModuleMethodRef
	"tiltX"				-> ModuleMethodRef
	"tiltY"				-> ModuleMethodRef
	"tiltZ"				-> ModuleMethodRef
	"initMeta"			-> ModuleMethodRef
	"backupID"			-> ModuleMethodRef
	"enable"			-> MetaMethodRef
	"finish" 			-> RegionMethodRef
	
	"finish" 			-> MetaMethodRef	%% Experimental
	
	"release" 			-> RegionMethodRef
	"atPrimaryBorder" 	-> RegionMethodRef
	"atSecondaryBorder" -> RegionMethodRef
	"assignTime" 		-> ConfigFieldID
	
	
	"connect" 			-> FuncActuationRef
	"disconnect" 		-> FuncActuationRef
	"extend"			-> FuncActuationRef
	"extendSet"			-> FuncActuationRef
	"retract" 			-> FuncActuationRef
	"retractSet"		-> FuncActuationRef
	"rotate" 			-> FuncActuationRef
	"stop" 				-> FuncActuationRef
	"rotating"			-> FuncActuationRef
	"rotateAbsolute"	-> FuncActuationRef
	
	
	
	lexical syntax
	"Main" 									-> SequencePrim
	"Choose" 								-> SequencePrim
	
	context-free syntax

	"@" "X" "[" Exp "]"								-> ModHolderRef{cons("ModHolderPrimNumRef"),prefer}
	"@" ID "[" Exp "]"								-> ModHolderRef{cons("ModHolderNumRef")}
	"@" ID "." ID									-> ModHolderRef{cons("ModHolderRef")}
	"@" ID 											-> ModHolderRef{cons("ModHolderRef")}
	"@X"											-> ModHolderRef{cons("ModHolderPrimRef"),prefer}
	
	"orientation" "matches" {OrientRef ","}* -> Exp{cons("OrientMatch")}
	
	
	MethodRef	"(" {Exp "," }* ")" ";"  -> Stmt{cons("FuncCall")}
	MethodRef 	"(" {Exp "," }* ")" 	 -> Exp{cons("FuncCall")}
	
		FuncRef  "(" {Exp "," }* ")" ";"	-> Stmt{cons("FuncCall")}
		FuncRef  "(" {Exp "," }* ")"   		-> Exp{cons("FuncCall")}
	FuncPrimRef2 "(" {Exp "," }* ")" ";"		-> Stmt{cons("FuncCall")}
	FuncPrimRef2 "(" {Exp "," }* ")" 		-> Exp{cons("FuncCall")}
	
	FuncPrimRef -> FuncPrimRef2{cons("FuncPrimRef")}
	FuncActuationRef -> FuncRef{cons("FuncActuationRef")}
	
	FuncPrimRef 	-> FuncRef{reject}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" InstrPost  -> Instr{cons("Instr"),prefer}

	"do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" -> Instr{cons("Instr")}
	
	
	Border -> Exp
	BorderName -> Border{cons("Border")}
	BorderName -> ID{reject}
	
	lexical syntax
	"TOP" 		-> BorderName
	"BOTTOM"	-> BorderName
	"LEFT"		-> BorderName
	"RIGHT"		-> BorderName
	
	
	
	
	
	
	
	
	
	
	