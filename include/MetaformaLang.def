definition
module lexical/MetaformaLang-Identifiers
exports
	sorts Id String Time Obj
	
lexical syntax
	[a-zA-Z][a-zA-Z0-9\_]* -> ID
    [0-9]+          -> INT
	~[\"]*	-> String
	
lexical restrictions
	ID -/- [a-zA-Z0-9\_]
	"var" -/- [a-zA-Z0-9\_]
	String -/- ~[\"]
	
	

lexical syntax
	
	"if"			-> ID {reject}
	"else"			-> ID {reject}
	"for"			-> ID {reject}
	"while"			-> ID {reject}
	"wait"			-> ID {reject}
	"until"			-> ID {reject}
	
	Const			-> ID {reject}
	Bool			-> ID {reject}
	Obj				-> ID {reject}
	Core			-> ID {reject}
	
	
	"false"			-> Bool
	"true"			-> Bool
	
	"MALE"			-> Const
	"FEMALE"		-> Const
	"WEST"			-> Const
	"EAST"			-> Const
	"NORTH"			-> Const
	"SOUTH"			-> Const
	
	"boolean"		-> Type
	"byte"			-> Type
	"void"			-> Type
	"byte" "[" "]"	-> Type
	
	"meta"			-> Obj
	"module"		-> Obj
	"region"		-> Obj
	"debug"			-> Obj
	"config"		-> Obj
	
	"connect"		-> Core
	"disconnect"	-> Core
	"rotate"		-> Core
	"stop"			-> Core
	"rotate_continuous"	-> Core


module Exp

imports Common
imports MetaformaLang
imports lexical/MetaformaLang-Identifiers

exports


  context-free syntax
	Ref		 				-> Exp
	"#(" NbsOp ")"			-> Exp{cons("NbsCount")}
	"$(" NbsOp ")"			-> Exp{cons("Nbs")}
%%	"!$(" NbsOp ")"			-> Exp{"NbsNone"}
	ConnFilter "," {NbsFilter ","}+	-> NbsOp{cons("NbsOp")}
	ConnFilter						-> NbsOp{cons("NbsOp")}
	Exp 					-> ConnFilter{cons("ConnFilter")}
	Exp "->" Exp			-> ConnFilter{cons("ConnFilter")}
	
	"module.metaPart" "==" MetaPart			-> NbsFilter{cons("metaPart")}
	"connected" ":" Exp				-> NbsFilter{cons("connected")}
	"inRegion" ":" Exp				-> NbsFilter{cons("inRegion")}
	"module.metaID" "==" Exp			-> NbsFilter{cons("withMetaID")}
	"connDest" ":" Exp				-> NbsFilter{cons("connDest")}
	"connSource" ":" Exp			-> NbsFilter{cons("connSource")}
	ModHolder					-> NbsFilter{cons("in")}
	
	ID 						-> MetaPart{cons("MetaPart")}
	INT						-> Exp{cons("Int")}
	Const					-> Exp{cons("Const")}
	Bool					-> Exp{cons("Bool")}
	ModHolder				-> Exp{cons("ModHolder")}
	"(" Exp ")"			    -> Exp{cons("Par")}
	"[" {Exp ","}* "]"		-> Exp{cons("ByteArr")}
	STRING					-> Exp{cons("String")}
	
	 
	
	Exp "%"	Exp					-> Exp{left,cons("Mod")}
	"!" Exp 					-> Exp{right,cons("Not")}
	"-" Exp 					-> Exp{right,cons("Min")}
	Exp "-" Exp 				-> Exp{right,cons("Min")}
	Exp "*" Exp					-> Exp{left,cons("Mul")}
	Exp "/" Exp					-> Exp{left,cons("Div")}
	Exp "+" Exp					-> Exp{left,cons("Plus")}
	Exp "-" Exp					-> Exp{left,cons("Min")}
	Exp "<" Exp					-> Exp{left,cons("Lt")} 
    Exp ">" Exp					-> Exp{left,cons("Gt")}
    Exp "<=" Exp				-> Exp{left,cons("LtEq")}
    Exp ">=" Exp				-> Exp{left,cons("GtEq")}
    Exp "==" Exp				-> Exp{left,cons("Eq")} 
    Exp "!=" Exp				-> Exp{left,cons("Neq")} 
	Exp "&&" Exp				-> Exp{left,cons("And")}
	Exp "||" Exp				-> Exp{left,cons("Or")}
	Exp "&" Exp					-> Exp{left,cons("AndBit")}
	Exp "|" Exp					-> Exp{left,cons("OrBit")}
	
	context-free priorities
	{
		Exp "%"	Exp					-> Exp
	} > {right:
		"!" Exp 					-> Exp
	} > { left:
		Exp "*" Exp					-> Exp
		Exp "/" Exp					-> Exp
	} > { left:
		Exp "+" Exp					-> Exp
		Exp "-" Exp					-> Exp
	} > { non-assoc:
    	Exp "<" Exp					-> Exp
    	Exp ">" Exp					-> Exp
    	Exp "<=" Exp				-> Exp
    	Exp ">=" Exp				-> Exp
    	Exp "==" Exp				-> Exp
    	Exp "!=" Exp				-> Exp
	} > {left:
		Exp "&&" Exp				-> Exp
	} > {left:
		Exp "||" Exp				-> Exp
	} > {left:
		Exp "&" Exp					-> Exp
	} > {left:	
		Exp "|" Exp					-> Exp
	}

module MetaformaLang

imports Common
imports Exp
imports lexical/MetaformaLang-Identifiers

exports

sorts	Group

  context-free start-symbols
  
    Start
 
  context-free syntax
  
  
  
   ModuleDef Definition*  Decl* 						-> Start {cons("Start"), scope(Include)}
    
    "module" ID 									-> ModuleDef{cons("Module")}
	
	"meta" "{" PartDecl* VarDecl* FuncDecl* "}" 	-> Definition{cons("MetaNS")}
	"module" "{" VarDecl* FuncDecl* "}" 			-> Definition{cons("ModuleNS")}
	
	"void" ID "(" {ListElem ","}* ")" "{" Decl* Stmt* "}"					-> FuncDecl{cons("FuncDecl")}
	Type ID "(" {ListElem ","}* ")" "{" Decl* Stmt* "return" Exp ";" "}"	-> FuncDecl{cons("FuncDecl")}
	
	Type ID 			-> ListElem{cons("Elem")}
	ID					-> Type{avoid}
	
	"packet" ID "{" VarDecl* "}" 					-> Decl{cons("Packet")}
	FuncDecl -> Decl

	
	Type {ID ","}+ ";" -> VarDecl{cons("VarDecl")}
	"part" "[" {ID ","}* "]" ";" -> PartDecl{cons("MetaPartDecl")}
	
	ID 					-> Ref{cons("VarRef")}
	ID "." ID 			-> Ref{cons("FieldRef")}
	Obj "." ID 			-> Ref{cons("FieldRef")}
	Ref "=" Exp			-> Assign{cons("Assign")}
	{Assign ","}*		-> AssignLst{cons("AssignList")}
	
	"state" ID "{" VarDecl* FuncDecl* Instr* "}" -> Definition{cons("State")}
	EvHdlr										 -> Definition
	"when" "(" Event ")" "{" VarDecl* Stmt* "}" -> EvHdlr{cons("EvHdlr")}
	
	EvHdlr -> Stmt
	
	"receive" "(" ID ID ")" -> Event{cons("Event")}
	Exp 					-> Event{cons("Event")}
	"rate" Ref				-> Rate{cons("Rate")}
	
	"unicast" ID "(" AssignLst ")" "on"  Exp  Rate? ";" -> Stmt{cons("Unicast")}
	"broadcast" ID "(" AssignLst ")" Rate? ";" -> Stmt{cons("Broadcast")}
	
	
	
	Ref "=" Exp ";" -> Stmt{cons("Assign")}
	
	ID  "(" {Exp "," }* ")"   			-> Exp{cons("FuncCall")}
	ID  "(" {Exp "," }* ")" ";"			-> Stmt{cons("FuncCall")}
	Obj "." ID 	"(" {Exp "," }* ")" ";"  -> Stmt{cons("FuncCall")}
	Obj "." ID 	"(" {Exp "," }* ")" 	 -> Exp{cons("FuncCall")}

	
	"{" Stmt* "}" -> Stmt{cons("Stmt")}
		
	"if" "(" Exp ")" Stmt "else" Stmt 		-> Stmt{cons("IfElse")}
	
	"if" "(" Exp ")" Stmt 					-> Stmt{cons("If")}
		
	Stmt -> Instr
	"goto" ID ";"							-> Stmt{cons("Goto")}
	"goto" ID "orientating" ID ";"			-> Stmt{cons("Goto")}
	
	"group" ID "[" {ID ","}* "]" ";"			-> Definition{cons("Group")}
	"group" ID	";"							-> Definition{cons("GroupMum")}
	
	"disconnect" "(" ModHolder "," ModHolder ")" ";"			-> Stmt{cons("Disconnect")}
	"connect" "(" ModHolder "," ModHolder ")" ";"			-> Stmt{cons("Connect")}
	"rotate" "(" ModHolder "," Exp ")" ";"			-> Stmt{cons("Rotate")}
	"rotate_continuous" "(" ModHolder "," Exp ")" ";"			-> Stmt{cons("RotateCont")}
	"stop" "(" ModHolder ")" ";"			-> Stmt{cons("Stop")}
	
	"for" "(" Type ID ":" ID")" "{" Stmt "}"				-> Stmt{cons("For")}
	
	"send" Type "(" {Assign ","}* ")"	"to" ID ";"			-> Stmt{cons("Send")}
	
	
	"wait" -> StopCondition {cons("Wait")}
	"until" -> StopCondition{cons("Until")}
	
	context-free priorities
	{
	"@" ID										-> ModHolder{cons("ModHolder")}
	} > {
	ID "@" ID									-> ModHolder{cons("ModHolder")}
	}
	
	context-free priorities
	{
		"do" "{" Decl* Stmt* "}" StopCondition "(" Exp ")" ";"  -> Instr{cons("Instr")}
	} > {
		"do" "{" Decl* Stmt* "}"  -> Instr{cons("Instr")}		
	}

module Common
imports MetaformaLang

exports

  lexical syntax
  
  	[0-9]+ "ms"			-> TIME
  
    
    
    "\"" StringChar* "\"" -> STRING
    ~[\"\n]               -> StringChar
    "\\\""                -> StringChar
    BackSlashChar         -> StringChar
    "\\"                  -> BackSlashChar
    
    [\ \t\n\r] -> LAYOUT
    
    [\*]                             -> CommentChar
    "/*" (~[\*] | CommentChar)* "*/" -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | EOF)     -> LAYOUT
    
    -> EOF
  
  lexical restrictions
  
    %% Ensure greedy matching for lexicals
  
    CommentChar   -/- [\/]
    INT           -/- [0-9]
    ID            -/- [a-zA-Z0-9\_]
    
    %% EOF may not be followed by any char
    
    EOF           -/- ~[]

    %% Backslash chars in strings may not be followed by " 
    
    BackSlashChar -/- [\"]

  context-free restrictions
  
    %% Ensure greedy matching for comments

    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/].[\/]
    LAYOUT? -/- [\/].[\*]

module MetaformaLang

imports Common
imports Exp
imports lexical/MetaformaLang-Identifiers

exports

sorts	Group

  context-free start-symbols
  
    Start
 
  context-free syntax
  
  
  
   ModuleDef Definition*  Decl* 						-> Start {cons("Start"), scope(Include)}
    
    "module" ID 									-> ModuleDef{cons("Module")}
	
	"meta" "{" PartDecl* VarDecl* FuncDecl* "}" 	-> Definition{cons("MetaNS")}
	"module" "{" VarDecl* FuncDecl* "}" 			-> Definition{cons("ModuleNS")}
	
	"void" ID "(" {ListElem ","}* ")" "{" Decl* Stmt* "}"					-> FuncDecl{cons("FuncDecl")}
	Type ID "(" {ListElem ","}* ")" "{" Decl* Stmt* "return" Exp ";" "}"	-> FuncDecl{cons("FuncDecl")}
	
	Type ID 			-> ListElem{cons("Elem")}
	ID					-> Type{avoid}
	
	"packet" ID "{" VarDecl* "}" 					-> Decl{cons("Packet")}
	FuncDecl -> Decl

	
	Type {ID ","}+ ";" -> VarDecl{cons("VarDecl")}
	"part" "[" {ID ","}* "]" ";" -> PartDecl{cons("MetaPartDecl")}
	
	ID 					-> Ref{cons("VarRef")}
	ID "." ID 			-> Ref{cons("FieldRef")}
	Obj "." ID 			-> Ref{cons("FieldRef")}
	Ref "=" Exp			-> Assign{cons("Assign")}
	{Assign ","}*		-> AssignLst{cons("AssignList")}
	
	"state" ID "{" VarDecl* FuncDecl* Instr* "}" -> Definition{cons("State")}
	EvHdlr										 -> Definition
	"when" "(" Event ")" "{" VarDecl* Stmt* "}" -> EvHdlr{cons("EvHdlr")}
	
	EvHdlr -> Stmt
	
	"receive" "(" ID ID ")" -> Event{cons("Event")}
	Exp 					-> Event{cons("Event")}
	"rate" Ref				-> Rate{cons("Rate")}
	
	"unicast" ID "(" AssignLst ")" "on"  Exp  Rate? ";" -> Stmt{cons("Unicast")}
	"broadcast" ID "(" AssignLst ")" Rate? ";" -> Stmt{cons("Broadcast")}
	
	
	
	Ref "=" Exp ";" -> Stmt{cons("Assign")}
	
	ID  "(" {Exp "," }* ")"   			-> Exp{cons("FuncCall")}
	ID  "(" {Exp "," }* ")" ";"			-> Stmt{cons("FuncCall")}
	Obj "." ID 	"(" {Exp "," }* ")" ";"  -> Stmt{cons("FuncCall")}
	Obj "." ID 	"(" {Exp "," }* ")" 	 -> Exp{cons("FuncCall")}

	
	"{" Stmt* "}" -> Stmt{cons("Stmt")}
		
	"if" "(" Exp ")" Stmt "else" Stmt 		-> Stmt{cons("IfElse")}
	
	"if" "(" Exp ")" Stmt 					-> Stmt{cons("If")}
		
	Stmt -> Instr
	"goto" ID ";"							-> Stmt{cons("Goto")}
	"goto" ID "orientating" ID ";"			-> Stmt{cons("Goto")}
	
	"group" ID "[" {ID ","}* "]" ";"			-> Definition{cons("Group")}
	"group" ID	";"							-> Definition{cons("GroupMum")}
	
	"disconnect" "(" ModHolder "," ModHolder ")" ";"			-> Stmt{cons("Disconnect")}
	"connect" "(" ModHolder "," ModHolder ")" ";"			-> Stmt{cons("Connect")}
	"rotate" "(" ModHolder "," Exp ")" ";"			-> Stmt{cons("Rotate")}
	"rotate_continuous" "(" ModHolder "," Exp ")" ";"			-> Stmt{cons("RotateCont")}
	"stop" "(" ModHolder ")" ";"			-> Stmt{cons("Stop")}
	
	"for" "(" Type ID ":" ID")" "{" Stmt "}"				-> Stmt{cons("For")}
	
	"send" Type "(" {Assign ","}* ")"	"to" ID ";"			-> Stmt{cons("Send")}
	
	
	"wait" -> StopCondition {cons("Wait")}
	"until" -> StopCondition{cons("Until")}
	
	context-free priorities
	{
	"@" ID										-> ModHolder{cons("ModHolder")}
	} > {
	ID "@" ID									-> ModHolder{cons("ModHolder")}
	}
	
	context-free priorities
	{
		"do" "{" Decl* Stmt* "}" StopCondition "(" Exp ")" ";"  -> Instr{cons("Instr")}
	} > {
		"do" "{" Decl* Stmt* "}"  -> Instr{cons("Instr")}		
	}