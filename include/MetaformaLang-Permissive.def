definition

module lexical/MetaformaLang-Identifiers
imports MetaformaLang

exports
  sorts WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR WATERTOKENSTAR

  lexical syntax
    ~[A-Za-z0-9\_]                 -> WATERTOKENSTART     {recover, avoid}
    WATERTOKENSTART [A-Za-z0-9\_]* -> WATERTOKEN          
    ~[A-Za-z0-9\_\ \t\12\r\n\*]    -> WATERTOKENSEPARATOR {recover, avoid}
    "*"                            -> WATERTOKENSTAR      {recover, avoid}
    WATERTOKEN                     -> WATER               
    WATERTOKENSEPARATOR            -> WATER               
    WATERTOKENSTAR                 -> WATER               
                                   -> WATEREOF            

  lexical restrictions
    WATERTOKEN -/- [A-Za-z0-9\_]
    WATERTOKENSTAR -/- [\/]

  context-free syntax
    WATER -> LAYOUT {cons("WATER")}

  (

  sorts WATEREOF

  lexical restrictions
    WATEREOF -/- ~[]

  lexical syntax
    %% Lexical insertion recovery rules                              
                                                  -> "$("            {recover, cons("INSERTION")}
    "\""                                          -> INSERTOPENQUOTE {recover}
    INSERTOPENQUOTE StringChar* "\n"              -> STRING          {cons("INSERTEND")}
    INSERTOPENQUOTE StringChar* WATEREOF          -> STRING          {cons("INSERTEND")}
    "/*"                                          -> INSERTSTART     {recover}
    INSERTSTART ( ~[\*] | CommentChar )* WATEREOF -> LAYOUT          {cons("INSERTEND")}
                                                  -> "program"       {recover, cons("INSERTION")}
                                                  -> "visualize"     {recover, cons("INSERTION")}
                                                  -> "packet"        {recover, cons("INSERTION")}
                                                  -> "part"          {recover, cons("INSERTION")}
                                                  -> "receive"       {recover, cons("INSERTION")}
                                                  -> "rate"          {recover, cons("INSERTION")}
                                                  -> "}"             {recover, cons("INSERTION")}
                                                  -> "]"             {recover, cons("INSERTION")}
                                                  -> "group"         {recover, cons("INSERTION")}
                                                  -> "wait"          {recover, cons("INSERTION")}
                                                  -> ";"             {recover, cons("INSERTION")}
                                                  -> "until"         {recover, cons("INSERTION")}
                                                  -> ")"             {recover, cons("INSERTION")}
                                                  -> ","             {recover, cons("INSERTION")}
                                                  -> "@"             {recover, cons("INSERTION")}

  syntax
    %% Kernel syntax insertion recovery rules   

  )

  (

  sorts Id String Time Obj

  lexical syntax
    [a-zA-Z] [a-zA-Z0-9\_]* -> ID     
    [0-9]+                  -> INT    
    ~[\"]*                  -> String 

  lexical restrictions
    ID -/- [a-zA-Z0-9\_]
    "var" -/- [a-zA-Z0-9\_]
    String -/- ~[\"]

  lexical syntax
    "if"                -> ID       {reject}
    "else"              -> ID       {reject}
    "for"               -> ID       {reject}
    "while"             -> ID       {reject}
    "wait"              -> ID       {reject}
    "until"             -> ID       {reject}
    "consensus"         -> ID       {reject}
    "goto"              -> ID       {reject}
    "when"              -> ID       {reject}
    "red"               -> Color    
    "blue"              -> Color    
    "green"             -> Color    
    "yellow"            -> Color    
    "cyan"              -> Color    
    "false"             -> Bool     
    "true"              -> Bool     
    "MALE"              -> ConstLan 
    "FEMALE"            -> ConstLan 
    "WEST"              -> ConstLan 
    "EAST"              -> ConstLan 
    "NORTH"             -> ConstLan 
    "SOUTH"             -> ConstLan 
    "MAX_BYTE"          -> Const    
    "null"              -> Const    
    "connect"           -> Core     
    "disconnect"        -> Core     
    "rotate"            -> Core     
    "stop"              -> Core     
    "rotate_continuous" -> Core     
    "disconnect_part"   -> Core     
    "connect_part"      -> Core     

  context-free syntax
    "boolean"      -> Type   {cons("Boolean")}
    "byte"         -> Type   {cons("Byte")}
    "void"         -> Type   {cons("Void")}
    "byte" "[" "]" -> Type   {cons("ByteArr")}
    "meta"         -> SysObj {cons("Meta")}
    "module"       -> SysObj {cons("Module")}
    "region"       -> SysObj {cons("Region")}
    "debug"        -> SysObj {cons("Debug")}
    "config"       -> SysObj {cons("Config")}
    "config"       -> SysObj {cons("Config")}
    Const          -> ID     {reject}
    ConstLan       -> ID     {reject}
    Bool           -> ID     {reject}
    SysObj         -> ID     {reject}
    Core           -> ID     {reject}

  )

module Exp
imports Common

imports MetaformaLang

imports lexical/MetaformaLang-Identifiers

exports
  context-free syntax
    Ref                  -> Exp       
    "#(" NbsOp ")"       -> Exp       {cons("NbsCount")}
    "$(" NbsOp ")"       -> Nbs       {cons("Nbs")}
    {NbsFilter ","}+     -> NbsOp     {cons("NbsOp")}
    NbsFilterKey ":" Exp -> NbsFilter {cons("NbsFilter")}

  lexical syntax
    "metaPart"   -> NbsFilterKey  
    "connected"  -> NbsFilterKey  
    "inRegion"   -> NbsFilterKey  
    "metaID"     -> NbsFilterKey  
    "connDest"   -> NbsFilterKey  
    "connSource" -> NbsFilterKey  
    ModHolderRef -> NbsFilterElem 

  context-free syntax
    ID                 -> MetaPart {cons("MetaPart")}
    INT                -> Exp      {cons("Int")}
    Const              -> Exp      {cons("Const")}
    ConstLan           -> Exp      {cons("Const")}
    Bool               -> Exp      {cons("Bool")}
    ModHolderRef       -> Exp      
    "(" Exp ")"        -> Exp      {cons("Par")}
    "[" {Exp ","}* "]" -> Exp      {cons("ByteArr")}
    STRING             -> Exp      {cons("String")}
    Exp "%" Exp        -> Exp      {left, cons("Modulo")}
    "!" Exp            -> Exp      {right, cons("Not")}
    "-" Exp            -> Exp      {right, cons("Min")}
    Exp "-" Exp        -> Exp      {right, cons("Min")}
    Exp "*" Exp        -> Exp      {left, cons("Mul")}
    Exp "/" Exp        -> Exp      {left, cons("Div")}
    Exp "+" Exp        -> Exp      {left, cons("Plus")}
    Exp "-" Exp        -> Exp      {left, cons("Min")}
    Exp "<" Exp        -> Exp      {left, cons("Lt")}
    Exp ">" Exp        -> Exp      {left, cons("Gt")}
    Exp "<=" Exp       -> Exp      {left, cons("LtEq")}
    Exp ">=" Exp       -> Exp      {left, cons("GtEq")}
    Exp "==" Exp       -> Exp      {left, cons("Eq")}
    Exp "!=" Exp       -> Exp      {left, cons("Neq")}
    Exp "&&" Exp       -> Exp      {left, cons("And")}
    Exp "||" Exp       -> Exp      {left, cons("Or")}
    Exp "&" Exp        -> Exp      {left, cons("AndBit")}
    Exp "|" Exp        -> Exp      {left, cons("OrBit")}

  context-free priorities
    { Exp "%" Exp -> Exp } >
    {right:
      "!" Exp -> Exp
    } >
    {left:
      Exp "*" Exp -> Exp
      Exp "/" Exp -> Exp
    } >
    {left:
      Exp "+" Exp -> Exp
      Exp "-" Exp -> Exp
    } >
    {non-assoc:
      Exp "<" Exp -> Exp
      Exp ">" Exp -> Exp
      Exp "<=" Exp -> Exp
      Exp ">=" Exp -> Exp
      Exp "==" Exp -> Exp
      Exp "!=" Exp -> Exp
    } >
    {left:
      Exp "&&" Exp -> Exp
    } >
    {left:
      Exp "||" Exp -> Exp
    } >
    {left:
      Exp "&" Exp -> Exp
    } >
    {left:
      Exp "|" Exp -> Exp
    }

module MetaformaLang
imports Common Exp lexical/MetaformaLang-Identifiers

exports
  sorts Group MetaClass

  context-free start-symbols
    Start

  context-free syntax
    "program" ID Visualize? Definition* Declaration*                                         -> Start               {cons("Program")}
    "visualize" "{" VisGroup* "}"                                                            -> Visualize           {cons("Visualize")}
    ID "{" VisItem* "}"                                                                      -> VisGroup            {cons("VisGroup")}
    ModHolderOrStateRef ":" Color [0-9] ";"                                                  -> VisItem             {cons("VisItem")}
    ModHolderRef                                                                             -> ModHolderOrStateRef 
    StateRef                                                                                 -> ModHolderOrStateRef 
    GroupDef                                                                                 -> Definition          
    Meta "{" PartDecl? FieldDecl* FuncDecl* "}"                                              -> Definition          {cons("Class")}
    Module "{" FieldDecl* FuncDecl* "}"                                                      -> Definition          {cons("Class")}
    "meta"                                                                                   -> Meta                {cons("Meta")}
    "module"                                                                                 -> Module              {cons("Module")}
    "void" ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "}"                        -> FuncDecl            {cons("FuncDecl")}
    Type ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "return" Exp ";" "}"         -> FuncDecl            {cons("FuncDecl")}
    Type ID                                                                                  -> ParamListElem       {cons("Param")}
    ID                                                                                       -> Type                {avoid}
    "packet" ID "{" PayloadDecl* "}"                                                         -> Definition          {cons("Packet")}
    FuncDecl                                                                                 -> Declaration         
    Type ID ";"                                                                              -> VarDecl             {cons("VarDecl")}
    Type ID ";"                                                                              -> FieldDecl           {cons("FieldDecl")}
    Type ID ";"                                                                              -> PayloadDecl         {cons("PayloadDecl")}
    PacketRef ID                                                                             -> PacketVarDecl       {cons("VarDecl")}
    "part" "[" {MetaPart ","}* "]" ";"                                                       -> PartDecl            {cons("MetaPartDecl")}
    ID                                                                                       -> MetaPart            {cons("MetaPart")}
    ID                                                                                       -> Ref                 {cons("VarRef")}
    ID                                                                                       -> PayloadRef          {cons("PayloadRef")}
    PayloadRef "=" ID                                                                        -> AssignElem          {cons("AssignElem")}
    {AssignElem ","}*                                                                        -> AssignList          {cons("AssignList")}
    "sequence" ID "{" EvHdlr* VarDecl* FuncDecl* Instr* "}"                                  -> Declaration         {cons("State")}
    EvHdlr                                                                                   -> Definition          
    "when" "(" Receive ")" "{" VarDecl* Stmt* "}"                                            -> EvHdlr              {cons("EvHdlr")}
    "when" "(" EventExp ")" "{" VarDecl* Stmt* "}"                                           -> Stmt                {cons("If")}
    ID                                                                                       -> PacketRef           {cons("PacketRef")}
    "receive" "(" PacketVarDecl ")"                                                          -> Receive             {cons("Receive")}
    Exp                                                                                      -> EventExp            
    "rate" Ref                                                                               -> Rate                {cons("Rate")}
    "unicast" PacketRef "(" AssignList ")" "to" Nbs Rate? ";"                                -> Stmt                {cons("Unicast")}
    Ref "=" Exp ";"                                                                          -> Stmt                {cons("Assign")}
    Stmt                                                                                     -> Block               {cons("Block")}
    "{" Stmt* "}"                                                                            -> Block               {cons("Block")}
    "if" "(" Exp ")" Block "else" Block                                                      -> Stmt                {cons("IfElse")}
    "if" "(" Exp ")" Block                                                                   -> Stmt                {cons("If")}
    ID                                                                                       -> StateRef            {cons("StateRef")}
    ID                                                                                       -> OrientRef           {cons("OrientRef")}
    Stmt                                                                                     -> Instr               
    "goto" StateRef ";"                                                                      -> Stmt                {cons("Goto")}
    "goto" ID "orientating" ID ";"                                                           -> Stmt                {cons("Goto")}
    "group" ID "[" {Mod ","}* "]"                                                            -> GroupDef            {cons("Group")}
    "group" ID                                                                               -> GroupDef            {cons("GroupNum")}
    ID                                                                                       -> Mod                 {cons("Mod")}
    "try" "region" StateRef "orientating" OrientRef "from" ByteList "excluding" ByteList ";" -> Stmt                {cons("TryRegion")}
    {Exp ","}*                                                                               -> ByteList            {cons("ByteArr")}
    "disconnect" "(" ModHolderRef "," ModHolderRef ")" ";"                                   -> Stmt                {cons("Disconnect")}
    "connect" "(" ModHolderRef "," ModHolderRef ")" ";"                                      -> Stmt                {cons("Connect")}
    "rotate" "(" ModHolderRef "," Exp ")" ";"                                                -> Stmt                {cons("Rotate")}
    "rotate_continuous" "(" ModHolderRef "," Exp ")" ";"                                     -> Stmt                {cons("RotateCont")}
    "disconnect_part" "(" ModHolderRef "," Exp ")" ";"                                       -> Stmt                {cons("DisconnectPart")}
    "connect_part" "(" ModHolderRef "," Exp ")" ";"                                          -> Stmt                {cons("ConnectPart")}
    "stop" "(" ModHolderRef ")" ";"                                                          -> Stmt                {cons("Stop")}
    "wait" "(" Stop ")" ";"                                                                  -> StopCondition       {cons("Wait")}
    "until" "(" Stop ")" ";"                                                                 -> StopCondition       {cons("Until")}
    "consensus" "(" ")"                                                                      -> Stop                {cons("Consensus")}
    Exp                                                                                      -> Stop                
    ID                                                                                       -> FuncRef             {cons("FuncRef")}
    Obj "." ID                                                                               -> MethodRef           {cons("MethodRef")}
    ID                                                                                       -> VarRef              {cons("VarRef")}
    "orientation" "matches" {OrientRef ","}*                                                 -> Exp                 {cons("OrientMatch")}
    "@" ID "." ID                                                                            -> ModHolderRef        {cons("ModHolderRef")}
    "@" ID                                                                                   -> ModHolderRef        {cons("ModHolderRef")}
    Obj "." ID                                                                               -> Ref                 {cons("FieldRef")}
    SysObj                                                                                   -> Obj                 
    ID                                                                                       -> Obj                 

  context-free priorities
    { "do" "{" EvHdlr* VarDecl* Stmt* "}" StopCondition -> Instr {cons("Instr")} } >
    { "do" "{" EvHdlr* VarDecl* Stmt* "}" -> Instr {cons("Instr")} }

  context-free priorities
    { MethodRef "(" {Exp ","}* ")" ";" -> Stmt {cons("FuncCall")}
      MethodRef "(" {Exp ","}* ")" -> Exp {cons("FuncCall")} } >
    { FuncRef "(" {Exp ","}* ")" -> Exp {cons("FuncCall")}
      FuncRef "(" {Exp ","}* ")" ";" -> Stmt {cons("FuncCall")} }

module Common
imports MetaformaLang

exports
  lexical syntax
    [0-9]+ "ms"                        -> TIME          
    "\"" StringChar* "\""              -> STRING        
    ~[\"\n]                            -> StringChar    
    "\\\""                             -> StringChar    
    BackSlashChar                      -> StringChar    
    "\\"                               -> BackSlashChar 
    [\ \t\n\r]                         -> LAYOUT        
    [\*]                               -> CommentChar   
    "/*" ( ~[\*] | CommentChar )* "*/" -> LAYOUT        
    "//" ~[\n\r]* [\n\r] | EOF         -> LAYOUT        
                                       -> EOF           

  lexical restrictions
    CommentChar -/- [\/]
    INT -/- [0-9]
    ID -/- [a-zA-Z0-9\_]
    EOF -/- ~[]
    BackSlashChar -/- [\"]

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/] . [\/]
    LAYOUT? -/- [\/] . [\*]

module MetaformaLang
imports Common Exp lexical/MetaformaLang-Identifiers

exports
  sorts Group MetaClass

  context-free start-symbols
    Start

  context-free syntax
    "program" ID Visualize? Definition* Declaration*                                         -> Start               {cons("Program")}
    "visualize" "{" VisGroup* "}"                                                            -> Visualize           {cons("Visualize")}
    ID "{" VisItem* "}"                                                                      -> VisGroup            {cons("VisGroup")}
    ModHolderOrStateRef ":" Color [0-9] ";"                                                  -> VisItem             {cons("VisItem")}
    ModHolderRef                                                                             -> ModHolderOrStateRef 
    StateRef                                                                                 -> ModHolderOrStateRef 
    GroupDef                                                                                 -> Definition          
    Meta "{" PartDecl? FieldDecl* FuncDecl* "}"                                              -> Definition          {cons("Class")}
    Module "{" FieldDecl* FuncDecl* "}"                                                      -> Definition          {cons("Class")}
    "meta"                                                                                   -> Meta                {cons("Meta")}
    "module"                                                                                 -> Module              {cons("Module")}
    "void" ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "}"                        -> FuncDecl            {cons("FuncDecl")}
    Type ID "(" {ParamListElem ","}* ")" "{" Declaration* Stmt* "return" Exp ";" "}"         -> FuncDecl            {cons("FuncDecl")}
    Type ID                                                                                  -> ParamListElem       {cons("Param")}
    ID                                                                                       -> Type                {avoid}
    "packet" ID "{" PayloadDecl* "}"                                                         -> Definition          {cons("Packet")}
    FuncDecl                                                                                 -> Declaration         
    Type ID ";"                                                                              -> VarDecl             {cons("VarDecl")}
    Type ID ";"                                                                              -> FieldDecl           {cons("FieldDecl")}
    Type ID ";"                                                                              -> PayloadDecl         {cons("PayloadDecl")}
    PacketRef ID                                                                             -> PacketVarDecl       {cons("VarDecl")}
    "part" "[" {MetaPart ","}* "]" ";"                                                       -> PartDecl            {cons("MetaPartDecl")}
    ID                                                                                       -> MetaPart            {cons("MetaPart")}
    ID                                                                                       -> Ref                 {cons("VarRef")}
    ID                                                                                       -> PayloadRef          {cons("PayloadRef")}
    PayloadRef "=" ID                                                                        -> AssignElem          {cons("AssignElem")}
    {AssignElem ","}*                                                                        -> AssignList          {cons("AssignList")}
    "sequence" ID "{" EvHdlr* VarDecl* FuncDecl* Instr* "}"                                  -> Declaration         {cons("State")}
    EvHdlr                                                                                   -> Definition          
    "when" "(" Receive ")" "{" VarDecl* Stmt* "}"                                            -> EvHdlr              {cons("EvHdlr")}
    "when" "(" EventExp ")" "{" VarDecl* Stmt* "}"                                           -> Stmt                {cons("If")}
    ID                                                                                       -> PacketRef           {cons("PacketRef")}
    "receive" "(" PacketVarDecl ")"                                                          -> Receive             {cons("Receive")}
    Exp                                                                                      -> EventExp            
    "rate" Ref                                                                               -> Rate                {cons("Rate")}
    "unicast" PacketRef "(" AssignList ")" "to" Nbs Rate? ";"                                -> Stmt                {cons("Unicast")}
    Ref "=" Exp ";"                                                                          -> Stmt                {cons("Assign")}
    Stmt                                                                                     -> Block               {cons("Block")}
    "{" Stmt* "}"                                                                            -> Block               {cons("Block")}
    "if" "(" Exp ")" Block "else" Block                                                      -> Stmt                {cons("IfElse")}
    "if" "(" Exp ")" Block                                                                   -> Stmt                {cons("If")}
    ID                                                                                       -> StateRef            {cons("StateRef")}
    ID                                                                                       -> OrientRef           {cons("OrientRef")}
    Stmt                                                                                     -> Instr               
    "goto" StateRef ";"                                                                      -> Stmt                {cons("Goto")}
    "goto" ID "orientating" ID ";"                                                           -> Stmt                {cons("Goto")}
    "group" ID "[" {Mod ","}* "]"                                                            -> GroupDef            {cons("Group")}
    "group" ID                                                                               -> GroupDef            {cons("GroupNum")}
    ID                                                                                       -> Mod                 {cons("Mod")}
    "try" "region" StateRef "orientating" OrientRef "from" ByteList "excluding" ByteList ";" -> Stmt                {cons("TryRegion")}
    {Exp ","}*                                                                               -> ByteList            {cons("ByteArr")}
    "disconnect" "(" ModHolderRef "," ModHolderRef ")" ";"                                   -> Stmt                {cons("Disconnect")}
    "connect" "(" ModHolderRef "," ModHolderRef ")" ";"                                      -> Stmt                {cons("Connect")}
    "rotate" "(" ModHolderRef "," Exp ")" ";"                                                -> Stmt                {cons("Rotate")}
    "rotate_continuous" "(" ModHolderRef "," Exp ")" ";"                                     -> Stmt                {cons("RotateCont")}
    "disconnect_part" "(" ModHolderRef "," Exp ")" ";"                                       -> Stmt                {cons("DisconnectPart")}
    "connect_part" "(" ModHolderRef "," Exp ")" ";"                                          -> Stmt                {cons("ConnectPart")}
    "stop" "(" ModHolderRef ")" ";"                                                          -> Stmt                {cons("Stop")}
    "wait" "(" Stop ")" ";"                                                                  -> StopCondition       {cons("Wait")}
    "until" "(" Stop ")" ";"                                                                 -> StopCondition       {cons("Until")}
    "consensus" "(" ")"                                                                      -> Stop                {cons("Consensus")}
    Exp                                                                                      -> Stop                
    ID                                                                                       -> FuncRef             {cons("FuncRef")}
    Obj "." ID                                                                               -> MethodRef           {cons("MethodRef")}
    ID                                                                                       -> VarRef              {cons("VarRef")}
    "orientation" "matches" {OrientRef ","}*                                                 -> Exp                 {cons("OrientMatch")}
    "@" ID "." ID                                                                            -> ModHolderRef        {cons("ModHolderRef")}
    "@" ID                                                                                   -> ModHolderRef        {cons("ModHolderRef")}
    Obj "." ID                                                                               -> Ref                 {cons("FieldRef")}
    SysObj                                                                                   -> Obj                 
    ID                                                                                       -> Obj                 

  context-free priorities
    { "do" "{" EvHdlr* VarDecl* Stmt* "}" StopCondition -> Instr {cons("Instr")} } >
    { "do" "{" EvHdlr* VarDecl* Stmt* "}" -> Instr {cons("Instr")} }

  context-free priorities
    { MethodRef "(" {Exp ","}* ")" ";" -> Stmt {cons("FuncCall")}
      MethodRef "(" {Exp ","}* ")" -> Exp {cons("FuncCall")} } >
    { FuncRef "(" {Exp ","}* ")" -> Exp {cons("FuncCall")}
      FuncRef "(" {Exp ","}* ")" ";" -> Stmt {cons("FuncCall")} }