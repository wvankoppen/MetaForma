definition

module lexical/MetaformaLang-Identifiers
imports MetaformaLang

exports
  sorts WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR WATERTOKENSTAR

  lexical syntax
    ~[A-Za-z0-9\_]                 -> WATERTOKENSTART     {recover, avoid}
    WATERTOKENSTART [A-Za-z0-9\_]* -> WATERTOKEN          
    ~[A-Za-z0-9\_\ \t\12\r\n\*]    -> WATERTOKENSEPARATOR {recover, avoid}
    "*"                            -> WATERTOKENSTAR      {recover, avoid}
    WATERTOKEN                     -> WATER               
    WATERTOKENSEPARATOR            -> WATER               
    WATERTOKENSTAR                 -> WATER               
                                   -> WATEREOF            

  lexical restrictions
    WATERTOKEN -/- [A-Za-z0-9\_]
    WATERTOKENSTAR -/- [\/]

  context-free syntax
    WATER -> LAYOUT {cons("WATER")}

  (

  sorts WATEREOF

  lexical restrictions
    WATEREOF -/- ~[]

  lexical syntax
    %% Lexical insertion recovery rules                              
                                                  -> "$("            {recover, cons("INSERTION")}
    "\""                                          -> INSERTOPENQUOTE {recover}
    INSERTOPENQUOTE StringChar* "\n"              -> STRING          {cons("INSERTEND")}
    INSERTOPENQUOTE StringChar* WATEREOF          -> STRING          {cons("INSERTEND")}
    "/*"                                          -> INSERTSTART     {recover}
    INSERTSTART ( ~[\*] | CommentChar )* WATEREOF -> LAYOUT          {cons("INSERTEND")}
                                                  -> "package"       {recover, cons("INSERTION")}
                                                  -> "show"          {recover, cons("INSERTION")}
                                                  -> "visualize"     {recover, cons("INSERTION")}
                                                  -> "borders"       {recover, cons("INSERTION")}
                                                  -> "packet"        {recover, cons("INSERTION")}
                                                  -> "part"          {recover, cons("INSERTION")}
                                                  -> "receive"       {recover, cons("INSERTION")}
                                                  -> "sequence"      {recover, cons("INSERTION")}
                                                  -> "strategy"      {recover, cons("INSERTION")}
                                                  -> "when"          {recover, cons("INSERTION")}
                                                  -> "case"          {recover, cons("INSERTION")}
                                                  -> "rate"          {recover, cons("INSERTION")}
                                                  -> "orienting"     {recover, cons("INSERTION")}
                                                  -> "group"         {recover, cons("INSERTION")}
                                                  -> "excluding"     {recover, cons("INSERTION")}
                                                  -> ";"             {recover, cons("INSERTION")}
                                                  -> "until"         {recover, cons("INSERTION")}
                                                  -> ")"             {recover, cons("INSERTION")}
                                                  -> "]"             {recover, cons("INSERTION")}
                                                  -> ","             {recover, cons("INSERTION")}
                                                  -> "}"             {recover, cons("INSERTION")}
                                                  -> "do"            {recover, cons("INSERTION")}

  syntax
    %% Kernel syntax insertion recovery rules   

  )

  (

  sorts Id String Time Obj

  lexical syntax
    [a-zA-Z] [a-zA-Z0-9\_]* -> ID     
    [0-9]+                  -> INT    
    [0-9]+? [\.] [0-9]+     -> FLOAT  
    ~[\"]*                  -> String 

  lexical restrictions
    ID -/- [a-zA-Z0-9\_]
    String -/- ~[\"]

  lexical syntax
    "if"             -> ID          {reject}
    "else"           -> ID          {reject}
    "for"            -> ID          {reject}
    "while"          -> ID          {reject}
    "wait"           -> ID          {reject}
    "until"          -> ID          {reject}
    "consensus"      -> ID          {reject}
    "goto"           -> ID          {reject}
    "when"           -> ID          {reject}
    "null"           -> ID          {reject}
    "red"            -> Color       
    "orange"         -> Color       
    "yellow"         -> Color       
    "blue"           -> Color       
    "green"          -> Color       
    "cyan"           -> Color       
    "white"          -> Color       
    "black"          -> Color       
    "gray"           -> Color       
    "magenta"        -> Color       
    "pink"           -> Color       
    "purple"         -> ColorCust   
    "brown"          -> ColorCust   
    "false"          -> Bool        
    "true"           -> Bool        
    "MALE"           -> ConstLan    
    "FEMALE"         -> ConstLan    
    "WEST"           -> ConstLan    
    "EAST"           -> ConstLan    
    "NORTH"          -> ConstLan    
    "SOUTH"          -> ConstLan    
    "MAX_BYTE"       -> ConstLan    
    "is"             -> FuncPrimRef 
    "min"            -> FuncPrimRef 
    "pow2"           -> FuncPrimRef 
    "mirror"         -> FuncPrimRef 
    FuncActuationRef -> ID          {reject}

  context-free syntax
    "null"         -> Exp    {cons("Null")}
    "boolean"      -> Type   {cons("Boolean")}
    "byte"         -> Type   {cons("Byte")}
    "int"          -> Type   {cons("Int")}
    "float"        -> Type   {cons("Float")}
    "void"         -> Type   {cons("Void")}
    "byte" "[" "]" -> Type   {cons("ByteArr")}
    "Packet"       -> Type   {cons("Packet")}
    "robot"        -> SysObj {cons("Robot")}
    "meta"         -> SysObj {cons("Meta")}
    "module"       -> SysObj {cons("Module")}
    "region"       -> SysObj {cons("Region")}
    "debug"        -> SysObj {cons("Debug")}
    "config"       -> SysObj {cons("Config")}
    ConstLan       -> ID     {reject}
    Bool           -> ID     {reject}
    SysObj         -> ID     {reject}

  )

module MetaformaLang-Exp
imports Common

imports MetaformaLang

imports lexical/MetaformaLang-Identifiers

exports
  context-free syntax
    Ref                  -> Exp       
    "#(" NbsOp ")"       -> Exp       {cons("NbsCount")}
    "$(" NbsOp ")"       -> Nbs       {cons("Nbs")}
    {NbsFilter ","}*     -> NbsOp     {cons("NbsOp")}
    NbsFilterKey ":" Exp -> NbsFilter {cons("NbsFilter")}
    ModHolderRef         -> NbsFilter {cons("NbsFilter")}

  lexical syntax
    "metaPart"   -> NbsFilterKey 
    "connected"  -> NbsFilterKey 
    "inRegion"   -> NbsFilterKey 
    "metaID"     -> NbsFilterKey 
    "connDest"   -> NbsFilterKey 
    "connSource" -> NbsFilterKey 

  context-free syntax
    ID                 -> MetaPart {cons("MetaPart")}
    INT                -> Exp      {cons("Int")}
    FLOAT              -> Exp      {cons("Float")}
    ConstLan           -> Exp      {cons("Const")}
    Bool               -> Exp      {cons("Bool")}
    ModHolderRef       -> Exp      
    "(" Exp ")"        -> Exp      {cons("Par")}
    "[" {Exp ","}* "]" -> Exp      {cons("ByteArr")}
    STRING             -> Exp      {cons("String")}
    Exp "%" Exp        -> Exp      {left, cons("Modulo")}
    "!" Exp            -> Exp      {right, cons("Not")}
    "-" Exp            -> Exp      {right, cons("Min")}
    Exp "-" Exp        -> Exp      {right, cons("Min")}
    Exp "*" Exp        -> Exp      {left, cons("Mul")}
    Exp "/" Exp        -> Exp      {left, cons("Div")}
    Exp "+" Exp        -> Exp      {left, cons("Plus")}
    Exp "-" Exp        -> Exp      {left, cons("Min")}
    Exp "<" Exp        -> Exp      {left, cons("Lt")}
    Exp ">" Exp        -> Exp      {left, cons("Gt")}
    Exp "<=" Exp       -> Exp      {left, cons("LtEq")}
    Exp ">=" Exp       -> Exp      {left, cons("GtEq")}
    Exp "==" Exp       -> Exp      {left, cons("Eq")}
    Exp "!=" Exp       -> Exp      {left, cons("Neq")}
    Exp "&&" Exp       -> Exp      {left, cons("And")}
    Exp "||" Exp       -> Exp      {left, cons("Or")}
    Exp "&" Exp        -> Exp      {left, cons("AndBit")}
    Exp "|" Exp        -> Exp      {left, cons("OrBit")}

  context-free priorities
    { Exp "%" Exp -> Exp } >
    {right:
      "!" Exp -> Exp
    } >
    {left:
      Exp "*" Exp -> Exp
      Exp "/" Exp -> Exp
    } >
    {left:
      Exp "+" Exp -> Exp
      Exp "-" Exp -> Exp
    } >
    {non-assoc:
      Exp "<" Exp -> Exp
      Exp ">" Exp -> Exp
      Exp "<=" Exp -> Exp
      Exp ">=" Exp -> Exp
      Exp "==" Exp -> Exp
      Exp "!=" Exp -> Exp
    } >
    {left:
      Exp "&&" Exp -> Exp
    } >
    {left:
      Exp "||" Exp -> Exp
    } >
    {left:
      Exp "&" Exp -> Exp
    } >
    {left:
      Exp "|" Exp -> Exp
    }

module MetaformaLang
imports Common MetaformaLang-Exp lexical/MetaformaLang-Identifiers

exports
  sorts MainDef Stmt Receive Sequence

  context-free start-symbols
    Start

  context-free syntax
    "package" ID Debug? MainDef*                                                                  -> Start             {cons("Package")}
    "debug" "{" ShowPackets? Visualize? "}"                                                       -> Debug             {cons("Debug")}
    "show" "[" {PacketRef ","}* "]"                                                               -> ShowPackets       {cons("ShowPackets")}
    "visualize" "{" VisGroup* "}"                                                                 -> Visualize         {cons("Visualize")}
    ID "{" VisItem* "}"                                                                           -> VisGroup          {cons("VisGroup")}
    ModHolderOrSeqRef ":" ColorRef ";"                                                            -> VisItem           {cons("VisItem")}
    Color                                                                                         -> ColorRef          {cons("Color")}
    ColorCust                                                                                     -> ColorRef          {cons("ColorCust")}
    ModHolderRef                                                                                  -> ModHolderOrSeqRef 
    SequenceRef                                                                                   -> ModHolderOrSeqRef 
    GroupDef                                                                                      -> MainDef           
    "meta" "{" PartDecl? FieldDecl* FuncDecl* "}"                                                 -> MainDef           {cons("Meta")}
    "module" "{" FieldDecl* FuncDecl* "}"                                                         -> MainDef           {cons("Module")}
    "region" "{" BorderDecl? FuncDecl* "}"                                                        -> MainDef           {cons("Region")}
    Type ID "=" Exp                                                                               -> MainDef           {cons("ConstDecl")}
    "borders" "[" BorderItem* "]"                                                                 -> BorderDecl        {cons("BorderDecl")}
    Border ":" Exp ";"                                                                            -> BorderItem        {cons("BorderItem")}
    "meta"                                                                                        -> Meta              {cons("Meta")}
    "module"                                                                                      -> Module            {cons("Module")}
    "region"                                                                                      -> Region            {cons("Region")}
    "config"                                                                                      -> Config            {cons("Config")}
    Type ID "(" {ParamListElem ","}* ")" "{" VarDecl* Stmt* "}"                                   -> FuncDecl          {cons("FuncDecl")}
    Type ID                                                                                       -> ParamListElem     {cons("Param")}
    "packet" ID "{" PayloadDecl* "}"                                                              -> MainDef           {cons("PacketDecl")}
    Type ID ";"                                                                                   -> VarDecl           {cons("VarDecl")}
    Type ID "=" Exp ";"                                                                           -> VarDecl           {cons("VarDecl")}
    Type ID ";"                                                                                   -> FieldDecl         {cons("FieldDecl")}
    Type ID ";"                                                                                   -> PayloadDecl       {cons("PayloadDecl")}
    PacketRef ID                                                                                  -> PacketVarDecl     {cons("PacketVarDecl")}
    "part" "[" {MetaPart ","}* "]" ";"                                                            -> PartDecl          {cons("MetaPartDecl")}
    ID                                                                                            -> MetaPart          {cons("MetaPart")}
    "None"                                                                                        -> ID                {reject}
    MetaPartNoneRef                                                                               -> Exp               {cons("MetaPartNoneRef")}
    ID                                                                                            -> Ref               {cons("VarRef")}
    ID                                                                                            -> PayloadRef        {cons("PayloadRef")}
    PayloadRef "=" Exp                                                                            -> AssignElem        {cons("AssignElem")}
    {AssignElem ","}*                                                                             -> AssignList        {cons("AssignList")}
    "unicast" PacketRef "(" AssignList ")" "to" Nbs ";"                                           -> Stmt              {cons("Unicast")}
    "receive" "(" PacketVarDecl ")"                                                               -> Receive           {cons("Receive")}
    "sequence" ID "{" EvHdlr* EvHdlrSemi* VarDecl* Instr* "}"                                     -> MainDef           {cons("Sequence")}
    "strategy" "{" Stmt* "}"                                                                      -> MainDef           {cons("Strategy")}
    "strategy;"                                                                                   -> Stmt              {cons("StrategyRef")}
    EvHdlr                                                                                        -> MainDef           
    "when" "(" Receive ")" "{" VarDecl* Stmt* "}"                                                 -> EvHdlr            {cons("EvHdlr")}
    "when" "(" EventExp ")" "{" VarDecl* Stmt* "}"                                                -> EvHdlrSemi        {cons("If")}
    "when" "{" Case* "}"                                                                          -> EvHdlrSemi        {cons("Ifs")}
    "case" Exp ":" Stmt*                                                                          -> Case              {cons("If")}
    ID                                                                                            -> PacketRef         {cons("Packet")}
    PacketPrim                                                                                    -> PacketRef         {cons("PacketPrim")}
    PacketPrim                                                                                    -> ID                {reject}
    Exp                                                                                           -> EventExp          
    "rate" Ref                                                                                    -> Rate              {cons("Rate")}
    Ref "=" Exp ";"                                                                               -> Stmt              {cons("Assign")}
    "return" Exp ";"                                                                              -> Stmt              {cons("Return")}
    Stmt                                                                                          -> Block             {cons("Block")}
    "{" Stmt* "}"                                                                                 -> Block             {cons("Block")}
    "if" "(" Exp ")" Block "else" Block                                                           -> Stmt              {cons("IfElse")}
    "if" "(" Exp ")" Block                                                                        -> Stmt              {cons("If")}
    Orient                                                                                        -> OrientRef         {cons("OrientRef")}
    Orient                                                                                        -> ID                {reject}
    Stmt                                                                                          -> Instr             
    "execute" SequenceRef ";"                                                                     -> Stmt              {cons("Goto")}
    "execute" SequenceRef OrientClause ";"                                                        -> Stmt              {cons("GotoOrient")}
    "orienting" OrientRef                                                                         -> OrientClause      {cons("Orientation")}
    "group" ID "[" {Mod ","}* "]"                                                                 -> GroupDef          {cons("Group")}
    "group" ID                                                                                    -> GroupDef          {cons("Group")}
    ID                                                                                            -> Mod               {cons("Mod")}
    "wait" "(" Exp ")" Block                                                                      -> Stmt              {cons("Wait")}
    "try" "region" SequenceRef OrientClause? "including" {MetaFieldRef ","}* ExcludingClause? ";" -> Stmt              {cons("TryRegion")}
    "excluding" {MetaFieldRef ","}*                                                               -> ExcludingClause   {cons("Excluding")}
    {Exp ","}*                                                                                    -> ByteList          {cons("ByteArr")}
    ID                                                                                            -> MetaFieldRef      {cons("MetaFieldRef")}
    "break" ";"                                                                                   -> Stmt              {cons("Break")}

  lexical syntax
    "LEFT_BOTTOM"  -> Orient          
    "LEFT_TOP"     -> Orient          
    "RIGHT_BOTTOM" -> Orient          
    "RIGHT_TOP"    -> Orient          
    "BOTTOM_LEFT"  -> Orient          
    "BOTTOM_RIGHT" -> Orient          
    "TOP_LEFT"     -> Orient          
    "TOP_RIGHT"    -> Orient          
    "None"         -> MetaPartNoneRef 
    "Packet"       -> PacketPrim      
    "Discover"     -> PacketPrim      
    "Consensus"    -> PacketPrim      
    "MetaVarSync"  -> PacketPrim      
    "Region"       -> PacketPrim      
    "Symmetry"     -> PacketPrim      

  context-free syntax
    Exp                               -> ModHolderOrExp 
    ModHolderRef                      -> ModHolderOrExp 
    "wait" "(" StopCondition ")" ";"  -> InstrPost      {cons("Wait")}
    "until" "(" StopCondition ")" ";" -> InstrPost      {cons("Until")}
    "consensus" "(" ")"               -> StopCondition  {cons("Consensus")}
    Exp                               -> StopCondition  
    ID                                -> FuncRef        {cons("FuncRef")}
    SysObj "." ID                     -> MethodRef      {cons("MethodRef")}
    Meta "." MetaMethodRef            -> MethodRef      {cons("MethodPrimRef")}
    Module "." ModuleMethodRef        -> MethodRef      {cons("MethodPrimRef")}
    Region "." RegionMethodRef        -> MethodRef      {cons("MethodPrimRef")}
    ID                                -> VarRef         {cons("VarRef")}
    SequencePrim                      -> SequenceRef    {cons("SequencePrimRef"), prefer}
    ID                                -> SequenceRef    {cons("SequenceRef")}
    Meta "." MetaFieldID              -> Ref            {cons("FieldPrimRef")}
    Module "." ModuleFieldID          -> Ref            {cons("FieldPrimRef")}
    Config "." ConfigFieldID          -> Ref            {cons("FieldPrimRef")}
    SysObj "." ID                     -> Ref            {cons("FieldRef")}
    PacketVarRef "." PayloadID        -> Ref            {cons("PayloadPrimRef")}
    PacketVarRef "." ID               -> Ref            {cons("PayloadRef")}
    VarRef                            -> PacketVarRef   
    ModuleFieldID                     -> ID             {reject}
    MetaFieldID                       -> ID             {reject}
    MetaMethodRef                     -> ID             {reject}
    ModuleMethodRef                   -> ID             {reject}
    RegionMethodRef                   -> ID             {reject}
    PayloadID                         -> ID             {reject}
    ConfigFieldID                     -> ID             {reject}

  lexical syntax
    "id"                -> ModuleFieldID    
    "metaID"            -> ModuleFieldID    
    "group"             -> ModuleFieldID    
    "metaPart"          -> ModuleFieldID    
    "assignTime"        -> ConfigFieldID    
    "propagationTime"   -> ConfigFieldID    
    "regionID"          -> MetaFieldID      
    "size"              -> MetaFieldID      
    "sizeExtra"         -> MetaFieldID      
    "sourceID"          -> PayloadID        
    "sourceGroup"       -> PayloadID        
    "metaID"            -> PayloadID        
    "regionID"          -> PayloadID        
    "connSource"        -> PayloadID        
    "connDest"          -> PayloadID        
    "restoreID"         -> ModuleMethodRef  
    "restoreSymmetry"   -> ModuleMethodRef  
    "atBorder"          -> ModuleMethodRef  
    "fixSymmetry"       -> ModuleMethodRef  
    "proximity"         -> ModuleMethodRef  
    "tiltX"             -> ModuleMethodRef  
    "tiltY"             -> ModuleMethodRef  
    "tiltZ"             -> ModuleMethodRef  
    "initMeta"          -> ModuleMethodRef  
    "backupID"          -> ModuleMethodRef  
    "enable"            -> MetaMethodRef    
    "finish"            -> RegionMethodRef  
    "finish"            -> MetaMethodRef    
    "release"           -> RegionMethodRef  
    "atPrimaryBorder"   -> RegionMethodRef  
    "atSecondaryBorder" -> RegionMethodRef  
    "assignTime"        -> ConfigFieldID    
    "connect"           -> FuncActuationRef 
    "disconnect"        -> FuncActuationRef 
    "extend"            -> FuncActuationRef 
    "extendSet"         -> FuncActuationRef 
    "retract"           -> FuncActuationRef 
    "retractSet"        -> FuncActuationRef 
    "rotate"            -> FuncActuationRef 
    "rotateOrigin"      -> FuncActuationRef 
    "stop"              -> FuncActuationRef 
    "rotating"          -> FuncActuationRef 
    "rotateAbsolute"    -> FuncActuationRef 

  lexical syntax
    "Main"   -> SequencePrim 
    "Choose" -> SequencePrim 

  context-free syntax
    "@" "X" "[" Exp "]"                                       -> ModHolderRef {cons("ModHolderPrimNumRef"), prefer}
    "@" ID "[" Exp "]"                                        -> ModHolderRef {cons("ModHolderNumRef")}
    "@" ID "." ID                                             -> ModHolderRef {cons("ModHolderRef")}
    "@" ID                                                    -> ModHolderRef {cons("ModHolderRef")}
    "@X"                                                      -> ModHolderRef {cons("ModHolderPrimRef"), prefer}
    "orientation" "matches" {OrientRef ","}*                  -> Exp          {cons("OrientMatch")}
    MethodRef "(" {Exp ","}* ")" ";"                          -> Stmt         {cons("FuncCall")}
    MethodRef "(" {Exp ","}* ")"                              -> Exp          {cons("FuncCall")}
    FuncRef "(" {Exp ","}* ")" ";"                            -> Stmt         {cons("FuncCall")}
    FuncRef "(" {Exp ","}* ")"                                -> Exp          {cons("FuncCall")}
    FuncPrimRef2 "(" {Exp ","}* ")" ";"                       -> Stmt         {cons("FuncCall")}
    FuncPrimRef2 "(" {Exp ","}* ")"                           -> Exp          {cons("FuncCall")}
    FuncPrimRef                                               -> FuncPrimRef2 {cons("FuncPrimRef")}
    FuncActuationRef                                          -> FuncRef      {cons("FuncActuationRef")}
    FuncPrimRef                                               -> FuncRef      {reject}
    "do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" InstrPost -> Instr        {cons("Instr"), prefer}
    "do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}"           -> Instr        {cons("Instr")}
    Border                                                    -> Exp          
    BorderName                                                -> Border       {cons("Border")}
    BorderName                                                -> ID           {reject}

  lexical syntax
    "TOP"    -> BorderName 
    "BOTTOM" -> BorderName 
    "LEFT"   -> BorderName 
    "RIGHT"  -> BorderName 

module Common
imports MetaformaLang

exports
  lexical syntax
    "\"" StringChar* "\""              -> STRING        
    ~[\"\n]                            -> StringChar    
    "\\\""                             -> StringChar    
    BackSlashChar                      -> StringChar    
    "\\"                               -> BackSlashChar 
    [\ \t\n\r]                         -> LAYOUT        
    [\*]                               -> CommentChar   
    "/*" ( ~[\*] | CommentChar )* "*/" -> LAYOUT        
    "//" ~[\n\r]* [\n\r] | EOF         -> LAYOUT        
                                       -> EOF           

  lexical restrictions
    CommentChar -/- [\/]
    INT -/- [0-9]
    ID -/- [a-zA-Z0-9\_]
    EOF -/- ~[]
    BackSlashChar -/- [\"]

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/] . [\/]
    LAYOUT? -/- [\/] . [\*]

module MetaformaLang
imports Common MetaformaLang-Exp lexical/MetaformaLang-Identifiers

exports
  sorts MainDef Stmt Receive Sequence

  context-free start-symbols
    Start

  context-free syntax
    "package" ID Debug? MainDef*                                                                  -> Start             {cons("Package")}
    "debug" "{" ShowPackets? Visualize? "}"                                                       -> Debug             {cons("Debug")}
    "show" "[" {PacketRef ","}* "]"                                                               -> ShowPackets       {cons("ShowPackets")}
    "visualize" "{" VisGroup* "}"                                                                 -> Visualize         {cons("Visualize")}
    ID "{" VisItem* "}"                                                                           -> VisGroup          {cons("VisGroup")}
    ModHolderOrSeqRef ":" ColorRef ";"                                                            -> VisItem           {cons("VisItem")}
    Color                                                                                         -> ColorRef          {cons("Color")}
    ColorCust                                                                                     -> ColorRef          {cons("ColorCust")}
    ModHolderRef                                                                                  -> ModHolderOrSeqRef 
    SequenceRef                                                                                   -> ModHolderOrSeqRef 
    GroupDef                                                                                      -> MainDef           
    "meta" "{" PartDecl? FieldDecl* FuncDecl* "}"                                                 -> MainDef           {cons("Meta")}
    "module" "{" FieldDecl* FuncDecl* "}"                                                         -> MainDef           {cons("Module")}
    "region" "{" BorderDecl? FuncDecl* "}"                                                        -> MainDef           {cons("Region")}
    Type ID "=" Exp                                                                               -> MainDef           {cons("ConstDecl")}
    "borders" "[" BorderItem* "]"                                                                 -> BorderDecl        {cons("BorderDecl")}
    Border ":" Exp ";"                                                                            -> BorderItem        {cons("BorderItem")}
    "meta"                                                                                        -> Meta              {cons("Meta")}
    "module"                                                                                      -> Module            {cons("Module")}
    "region"                                                                                      -> Region            {cons("Region")}
    "config"                                                                                      -> Config            {cons("Config")}
    Type ID "(" {ParamListElem ","}* ")" "{" VarDecl* Stmt* "}"                                   -> FuncDecl          {cons("FuncDecl")}
    Type ID                                                                                       -> ParamListElem     {cons("Param")}
    "packet" ID "{" PayloadDecl* "}"                                                              -> MainDef           {cons("PacketDecl")}
    Type ID ";"                                                                                   -> VarDecl           {cons("VarDecl")}
    Type ID "=" Exp ";"                                                                           -> VarDecl           {cons("VarDecl")}
    Type ID ";"                                                                                   -> FieldDecl         {cons("FieldDecl")}
    Type ID ";"                                                                                   -> PayloadDecl       {cons("PayloadDecl")}
    PacketRef ID                                                                                  -> PacketVarDecl     {cons("PacketVarDecl")}
    "part" "[" {MetaPart ","}* "]" ";"                                                            -> PartDecl          {cons("MetaPartDecl")}
    ID                                                                                            -> MetaPart          {cons("MetaPart")}
    "None"                                                                                        -> ID                {reject}
    MetaPartNoneRef                                                                               -> Exp               {cons("MetaPartNoneRef")}
    ID                                                                                            -> Ref               {cons("VarRef")}
    ID                                                                                            -> PayloadRef        {cons("PayloadRef")}
    PayloadRef "=" Exp                                                                            -> AssignElem        {cons("AssignElem")}
    {AssignElem ","}*                                                                             -> AssignList        {cons("AssignList")}
    "unicast" PacketRef "(" AssignList ")" "to" Nbs ";"                                           -> Stmt              {cons("Unicast")}
    "receive" "(" PacketVarDecl ")"                                                               -> Receive           {cons("Receive")}
    "sequence" ID "{" EvHdlr* EvHdlrSemi* VarDecl* Instr* "}"                                     -> MainDef           {cons("Sequence")}
    "strategy" "{" Stmt* "}"                                                                      -> MainDef           {cons("Strategy")}
    "strategy;"                                                                                   -> Stmt              {cons("StrategyRef")}
    EvHdlr                                                                                        -> MainDef           
    "when" "(" Receive ")" "{" VarDecl* Stmt* "}"                                                 -> EvHdlr            {cons("EvHdlr")}
    "when" "(" EventExp ")" "{" VarDecl* Stmt* "}"                                                -> EvHdlrSemi        {cons("If")}
    "when" "{" Case* "}"                                                                          -> EvHdlrSemi        {cons("Ifs")}
    "case" Exp ":" Stmt*                                                                          -> Case              {cons("If")}
    ID                                                                                            -> PacketRef         {cons("Packet")}
    PacketPrim                                                                                    -> PacketRef         {cons("PacketPrim")}
    PacketPrim                                                                                    -> ID                {reject}
    Exp                                                                                           -> EventExp          
    "rate" Ref                                                                                    -> Rate              {cons("Rate")}
    Ref "=" Exp ";"                                                                               -> Stmt              {cons("Assign")}
    "return" Exp ";"                                                                              -> Stmt              {cons("Return")}
    Stmt                                                                                          -> Block             {cons("Block")}
    "{" Stmt* "}"                                                                                 -> Block             {cons("Block")}
    "if" "(" Exp ")" Block "else" Block                                                           -> Stmt              {cons("IfElse")}
    "if" "(" Exp ")" Block                                                                        -> Stmt              {cons("If")}
    Orient                                                                                        -> OrientRef         {cons("OrientRef")}
    Orient                                                                                        -> ID                {reject}
    Stmt                                                                                          -> Instr             
    "execute" SequenceRef ";"                                                                     -> Stmt              {cons("Goto")}
    "execute" SequenceRef OrientClause ";"                                                        -> Stmt              {cons("GotoOrient")}
    "orienting" OrientRef                                                                         -> OrientClause      {cons("Orientation")}
    "group" ID "[" {Mod ","}* "]"                                                                 -> GroupDef          {cons("Group")}
    "group" ID                                                                                    -> GroupDef          {cons("Group")}
    ID                                                                                            -> Mod               {cons("Mod")}
    "wait" "(" Exp ")" Block                                                                      -> Stmt              {cons("Wait")}
    "try" "region" SequenceRef OrientClause? "including" {MetaFieldRef ","}* ExcludingClause? ";" -> Stmt              {cons("TryRegion")}
    "excluding" {MetaFieldRef ","}*                                                               -> ExcludingClause   {cons("Excluding")}
    {Exp ","}*                                                                                    -> ByteList          {cons("ByteArr")}
    ID                                                                                            -> MetaFieldRef      {cons("MetaFieldRef")}
    "break" ";"                                                                                   -> Stmt              {cons("Break")}

  lexical syntax
    "LEFT_BOTTOM"  -> Orient          
    "LEFT_TOP"     -> Orient          
    "RIGHT_BOTTOM" -> Orient          
    "RIGHT_TOP"    -> Orient          
    "BOTTOM_LEFT"  -> Orient          
    "BOTTOM_RIGHT" -> Orient          
    "TOP_LEFT"     -> Orient          
    "TOP_RIGHT"    -> Orient          
    "None"         -> MetaPartNoneRef 
    "Packet"       -> PacketPrim      
    "Discover"     -> PacketPrim      
    "Consensus"    -> PacketPrim      
    "MetaVarSync"  -> PacketPrim      
    "Region"       -> PacketPrim      
    "Symmetry"     -> PacketPrim      

  context-free syntax
    Exp                               -> ModHolderOrExp 
    ModHolderRef                      -> ModHolderOrExp 
    "wait" "(" StopCondition ")" ";"  -> InstrPost      {cons("Wait")}
    "until" "(" StopCondition ")" ";" -> InstrPost      {cons("Until")}
    "consensus" "(" ")"               -> StopCondition  {cons("Consensus")}
    Exp                               -> StopCondition  
    ID                                -> FuncRef        {cons("FuncRef")}
    SysObj "." ID                     -> MethodRef      {cons("MethodRef")}
    Meta "." MetaMethodRef            -> MethodRef      {cons("MethodPrimRef")}
    Module "." ModuleMethodRef        -> MethodRef      {cons("MethodPrimRef")}
    Region "." RegionMethodRef        -> MethodRef      {cons("MethodPrimRef")}
    ID                                -> VarRef         {cons("VarRef")}
    SequencePrim                      -> SequenceRef    {cons("SequencePrimRef"), prefer}
    ID                                -> SequenceRef    {cons("SequenceRef")}
    Meta "." MetaFieldID              -> Ref            {cons("FieldPrimRef")}
    Module "." ModuleFieldID          -> Ref            {cons("FieldPrimRef")}
    Config "." ConfigFieldID          -> Ref            {cons("FieldPrimRef")}
    SysObj "." ID                     -> Ref            {cons("FieldRef")}
    PacketVarRef "." PayloadID        -> Ref            {cons("PayloadPrimRef")}
    PacketVarRef "." ID               -> Ref            {cons("PayloadRef")}
    VarRef                            -> PacketVarRef   
    ModuleFieldID                     -> ID             {reject}
    MetaFieldID                       -> ID             {reject}
    MetaMethodRef                     -> ID             {reject}
    ModuleMethodRef                   -> ID             {reject}
    RegionMethodRef                   -> ID             {reject}
    PayloadID                         -> ID             {reject}
    ConfigFieldID                     -> ID             {reject}

  lexical syntax
    "id"                -> ModuleFieldID    
    "metaID"            -> ModuleFieldID    
    "group"             -> ModuleFieldID    
    "metaPart"          -> ModuleFieldID    
    "assignTime"        -> ConfigFieldID    
    "propagationTime"   -> ConfigFieldID    
    "regionID"          -> MetaFieldID      
    "size"              -> MetaFieldID      
    "sizeExtra"         -> MetaFieldID      
    "sourceID"          -> PayloadID        
    "sourceGroup"       -> PayloadID        
    "metaID"            -> PayloadID        
    "regionID"          -> PayloadID        
    "connSource"        -> PayloadID        
    "connDest"          -> PayloadID        
    "restoreID"         -> ModuleMethodRef  
    "restoreSymmetry"   -> ModuleMethodRef  
    "atBorder"          -> ModuleMethodRef  
    "fixSymmetry"       -> ModuleMethodRef  
    "proximity"         -> ModuleMethodRef  
    "tiltX"             -> ModuleMethodRef  
    "tiltY"             -> ModuleMethodRef  
    "tiltZ"             -> ModuleMethodRef  
    "initMeta"          -> ModuleMethodRef  
    "backupID"          -> ModuleMethodRef  
    "enable"            -> MetaMethodRef    
    "finish"            -> RegionMethodRef  
    "finish"            -> MetaMethodRef    
    "release"           -> RegionMethodRef  
    "atPrimaryBorder"   -> RegionMethodRef  
    "atSecondaryBorder" -> RegionMethodRef  
    "assignTime"        -> ConfigFieldID    
    "connect"           -> FuncActuationRef 
    "disconnect"        -> FuncActuationRef 
    "extend"            -> FuncActuationRef 
    "extendSet"         -> FuncActuationRef 
    "retract"           -> FuncActuationRef 
    "retractSet"        -> FuncActuationRef 
    "rotate"            -> FuncActuationRef 
    "rotateOrigin"      -> FuncActuationRef 
    "stop"              -> FuncActuationRef 
    "rotating"          -> FuncActuationRef 
    "rotateAbsolute"    -> FuncActuationRef 

  lexical syntax
    "Main"   -> SequencePrim 
    "Choose" -> SequencePrim 

  context-free syntax
    "@" "X" "[" Exp "]"                                       -> ModHolderRef {cons("ModHolderPrimNumRef"), prefer}
    "@" ID "[" Exp "]"                                        -> ModHolderRef {cons("ModHolderNumRef")}
    "@" ID "." ID                                             -> ModHolderRef {cons("ModHolderRef")}
    "@" ID                                                    -> ModHolderRef {cons("ModHolderRef")}
    "@X"                                                      -> ModHolderRef {cons("ModHolderPrimRef"), prefer}
    "orientation" "matches" {OrientRef ","}*                  -> Exp          {cons("OrientMatch")}
    MethodRef "(" {Exp ","}* ")" ";"                          -> Stmt         {cons("FuncCall")}
    MethodRef "(" {Exp ","}* ")"                              -> Exp          {cons("FuncCall")}
    FuncRef "(" {Exp ","}* ")" ";"                            -> Stmt         {cons("FuncCall")}
    FuncRef "(" {Exp ","}* ")"                                -> Exp          {cons("FuncCall")}
    FuncPrimRef2 "(" {Exp ","}* ")" ";"                       -> Stmt         {cons("FuncCall")}
    FuncPrimRef2 "(" {Exp ","}* ")"                           -> Exp          {cons("FuncCall")}
    FuncPrimRef                                               -> FuncPrimRef2 {cons("FuncPrimRef")}
    FuncActuationRef                                          -> FuncRef      {cons("FuncActuationRef")}
    FuncPrimRef                                               -> FuncRef      {reject}
    "do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}" InstrPost -> Instr        {cons("Instr"), prefer}
    "do" "{" EvHdlr* EvHdlrSemi* VarDecl* Stmt* "}"           -> Instr        {cons("Instr")}
    Border                                                    -> Exp          
    BorderName                                                -> Border       {cons("Border")}
    BorderName                                                -> ID           {reject}

  lexical syntax
    "TOP"    -> BorderName 
    "BOTTOM" -> BorderName 
    "LEFT"   -> BorderName 
    "RIGHT"  -> BorderName 